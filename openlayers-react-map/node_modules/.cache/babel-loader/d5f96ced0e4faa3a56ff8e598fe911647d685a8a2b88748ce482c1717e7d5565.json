{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature;\n  } else if (/** @type {import(\"../Collection.js\").CollectionEvent} */evt.element) {\n    return /** @type {import(\"../Feature.js\").default} */ /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element;\n  }\n}\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nvar Snap = /** @class */function (_super) {\n  __extends(Snap, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  function Snap(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    _this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    _this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    _this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    _this.GEOMETRY_SEGMENTERS_ = {\n      'Point': _this.segmentPointGeometry_.bind(_this),\n      'LineString': _this.segmentLineStringGeometry_.bind(_this),\n      'LinearRing': _this.segmentLineStringGeometry_.bind(_this),\n      'Polygon': _this.segmentPolygonGeometry_.bind(_this),\n      'MultiPoint': _this.segmentMultiPointGeometry_.bind(_this),\n      'MultiLineString': _this.segmentMultiLineStringGeometry_.bind(_this),\n      'MultiPolygon': _this.segmentMultiPolygonGeometry_.bind(_this),\n      'GeometryCollection': _this.segmentGeometryCollectionGeometry_.bind(_this),\n      'Circle': _this.segmentCircleGeometry_.bind(_this)\n    };\n    return _this;\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.addFeature = function (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        var segments = /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */[];\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          var extents = segments.map(function (s) {\n            return boundingExtent(s);\n          });\n          var segmentsData = segments.map(function (segment) {\n            return {\n              feature: feature,\n              segment: segment\n            };\n          });\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureAdd_ = function (feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureRemove_ = function (feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  Snap.prototype.getFeatures_ = function () {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  Snap.prototype.handleEvent = function (evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureAdd_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureRemove_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureChange_ = function (evt) {\n    var feature = /** @type {import(\"../Feature.js\").default} */evt.target;\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  Snap.prototype.handleUpEvent = function (evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove_1.push(node);\n        }\n      });\n      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove_1[i]);\n      }\n    }\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  Snap.prototype.setMap = function (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = /** @type {Array<import(\"../Feature.js\").default>} */this.getFeatures_();\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n    var segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    var closestVertex;\n    var minSquaredDistance = Infinity;\n    var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    var getResult = function () {\n      if (closestVertex) {\n        var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])]\n          };\n        }\n      }\n      return null;\n    };\n    if (this.vertex_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach(function (vertex) {\n            var tempVertexCoord = fromUserCoordinate(vertex, projection);\n            var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n      var result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    if (this.edge_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var vertex = null;\n        var segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          var circleGeometry = segmentData.feature.getGeometry();\n          var userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n          }\n          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, /** @type {import(\"../geom/Circle.js\").default} */circleGeometry), projection);\n        } else {\n          var _a = segmentData.segment,\n            segmentStart = _a[0],\n            segmentEnd = _a[1];\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          var delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n      var result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  Snap.prototype.updateFeature_ = function (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentCircleGeometry_ = function (segments, geometry) {\n    var projection = this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */circleGeometry.clone().transform(userProjection, projection);\n    }\n    var polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    var coordinates = polygon.getCoordinates()[0];\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentGeometryCollectionGeometry_ = function (segments, geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentLineStringGeometry_ = function (segments, geometry) {\n    var coordinates = geometry.getCoordinates();\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentMultiLineStringGeometry_ = function (segments, geometry) {\n    var lines = geometry.getCoordinates();\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentMultiPointGeometry_ = function (segments, geometry) {\n    geometry.getCoordinates().forEach(function (point) {\n      segments.push([point]);\n    });\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentMultiPolygonGeometry_ = function (segments, geometry) {\n    var polygons = geometry.getCoordinates();\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentPointGeometry_ = function (segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.segmentPolygonGeometry_ = function (segments, geometry) {\n    var rings = geometry.getCoordinates();\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n  return Snap;\n}(PointerInteraction);\nexport default Snap;","map":{"version":3,"names":["CollectionEventType","EventType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","boundingExtent","createEmpty","closestOnCircle","closestOnSegment","squaredDistance","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","getUid","getValues","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","Snap","_super","__extends","opt_options","_this","options","pointerOptions","handleDownEvent","stopDown","call","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","bind","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","prototype","addFeature","opt_listen","register","feature_uid","geometry","getGeometry","segmenter","getType","getExtent","segments","length","insert","segment","extents","map","s","segmentsData","load","CHANGE","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","removeFeature","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","slice","vertexPixel","handleFeatureAdd_","handleFeatureRemove_","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","forEach","opt_unlisten","unregister","extent","rBush","nodesToRemove_1","forEachInExtent","node","push","i","remove","setMap","currentMap","getMap","keys","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","getInExtent","segmentsLength","projection","getView","getProjection","projectedCoordinate","closestVertex","minSquaredDistance","Infinity","squaredPixelTolerance","getResult","getPixelFromCoordinate","squaredPixelDistance","Math","round","segmentData","tempVertexCoord","delta","circleGeometry","userProjection","clone","transform","_a","segmentStart","segmentEnd","polygon","coordinates","getCoordinates","ii","geometries","getGeometriesArray","lines","j","jj","point","polygons","k","kk","rings"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\interaction\\Snap.js"],"sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {getValues} from '../obj.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  } else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element\n  ) {\n    return /** @type {import(\"../Feature.js\").default} */ (\n      /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element\n    );\n  }\n}\n\nconst tempSegment = [];\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, opt_listen) {\n    const register = opt_listen !== undefined ? opt_listen : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, opt_unlisten) {\n    const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const lowerLeft = map.getCoordinateFromPixel([\n      pixel[0] - this.pixelTolerance_,\n      pixel[1] + this.pixelTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      pixel[0] + this.pixelTolerance_,\n      pixel[1] - this.pixelTolerance_,\n    ]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    const segments = this.rBush_.getInExtent(box);\n\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = toUserCoordinate(\n            closestOnCircle(\n              projectedCoordinate,\n              /** @type {import(\"../geom/Circle.js\").default} */ (\n                circleGeometry\n              )\n            ),\n            projection\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}