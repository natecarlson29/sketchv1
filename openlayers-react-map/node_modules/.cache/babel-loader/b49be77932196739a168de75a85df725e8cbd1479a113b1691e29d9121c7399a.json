{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ncarl\\\\Desktop\\\\sketch\\\\openlayers-react-map\\\\src\\\\map-actions\\\\RightClick.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect } from 'react';\nimport { Feature } from 'ol';\nimport LineString from 'ol/geom/LineString';\nimport Modal from '../map-helpers/Modal';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nlet showModal = false;\nlet modalMessage = '';\nconst RightClick = ({\n  mapRef,\n  vectorSourceRef,\n  contextMenu,\n  setContextMenu,\n  clearPolygonOverlays: clearOverlaysProp,\n  addHistoryAction,\n  drawing\n}) => {\n  _s();\n  useEffect(() => {\n    function handleCustomContextMenu(e) {\n      const mapDiv = document.getElementById('map');\n      if (!mapDiv || !mapRef.current || !vectorSourceRef.current) return;\n      if (!mapDiv.contains(e.target)) return;\n      e.preventDefault();\n      const pixel = mapRef.current.getEventPixel(e);\n      const features = vectorSourceRef.current.getFeatures();\n      let found = false;\n      for (const feature of features) {\n        const geom = feature.getGeometry();\n        let coords = null;\n        if (geom.getType() === 'Polygon') {\n          coords = geom.getCoordinates()[0];\n        } else if (geom.getType() === 'LineString') {\n          coords = geom.getCoordinates();\n        }\n        if (coords) {\n          // For polygons, skip last duplicate point\n          const len = geom.getType() === 'Polygon' ? coords.length - 1 : coords.length;\n          for (let i = 0; i < len; i++) {\n            const coordPixel = mapRef.current.getPixelFromCoordinate(coords[i]);\n            if (Math.hypot(pixel[0] - coordPixel[0], pixel[1] - coordPixel[1]) < 8) {\n              setContextMenu({\n                visible: true,\n                x: e.clientX,\n                y: e.clientY,\n                type: 'vertex',\n                feature,\n                index: i\n              });\n              found = true;\n              break;\n            }\n          }\n        }\n        if (found) break;\n      }\n      if (!found) {\n        for (const feature of features) {\n          const geom = feature.getGeometry();\n          let coords = null;\n          if (geom.getType() === 'Polygon') {\n            coords = geom.getCoordinates()[0];\n          } else if (geom.getType() === 'LineString') {\n            coords = geom.getCoordinates();\n          }\n          if (coords) {\n            // For polygons, skip last duplicate point\n            const len = geom.getType() === 'Polygon' ? coords.length - 1 : coords.length - 1;\n            for (let i = 0; i < len; i++) {\n              const c1 = mapRef.current.getPixelFromCoordinate(coords[i]);\n              const c2 = mapRef.current.getPixelFromCoordinate(coords[i + 1]);\n              const t = ((pixel[0] - c1[0]) * (c2[0] - c1[0]) + (pixel[1] - c1[1]) * (c2[1] - c1[1])) / ((c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2);\n              if (t >= 0 && t <= 1) {\n                const proj = [c1[0] + t * (c2[0] - c1[0]), c1[1] + t * (c2[1] - c1[1])];\n                if (Math.hypot(pixel[0] - proj[0], pixel[1] - proj[1]) < 8) {\n                  setContextMenu({\n                    visible: true,\n                    x: e.clientX,\n                    y: e.clientY,\n                    type: 'segment',\n                    feature,\n                    index: i\n                  });\n                  found = true;\n                  break;\n                }\n              }\n            }\n          }\n          if (found) break;\n        }\n      }\n      if (!found) setContextMenu({\n        visible: true,\n        x: e.clientX,\n        y: e.clientY,\n        type: null,\n        feature: null,\n        index: null\n      });\n    }\n    document.addEventListener('contextmenu', handleCustomContextMenu);\n    return () => document.removeEventListener('contextmenu', handleCustomContextMenu);\n  }, [mapRef, vectorSourceRef, setContextMenu]);\n  useEffect(() => {\n    function hideMenu() {\n      setContextMenu(menu => menu.visible ? {\n        ...menu,\n        visible: false\n      } : menu);\n    }\n    window.addEventListener('click', hideMenu);\n    return () => window.removeEventListener('click', hideMenu);\n  }, [setContextMenu]);\n\n  // Helper to deep clone coordinates\n  const cloneCoords = coords => coords.map(c => Array.isArray(c) ? [...c] : c);\n  const handleMenuAction = action => {\n    if (!contextMenu.feature) return;\n    const geom = contextMenu.feature.getGeometry();\n    let coords;\n    if (geom.getType() === 'Polygon') {\n      const arr = geom.getCoordinates()[0];\n      if (!Array.isArray(arr) || arr.length < 3 || !Array.isArray(arr[0])) return;\n      coords = arr.map(c => [c[0], c[1]]);\n    } else if (geom.getType() === 'LineString') {\n      const arr = geom.getCoordinates();\n      if (!Array.isArray(arr) || arr.length < 2 || !Array.isArray(arr[0])) return;\n      coords = arr.map(c => [c[0], c[1]]);\n    } else {\n      return;\n    }\n\n    // if (action === 'delete-vertex' && coords.length > 3) {\n    //   const prevCoords = cloneCoords(coords);\n    //   const newCoords = cloneCoords(coords);\n    //   newCoords.splice(contextMenu.index, 1);\n    //   newCoords[newCoords.length - 1] = newCoords[0];\n    //   geom.setCoordinates([newCoords]);\n    //   if (mapRef.current && mapRef.current.createSegmentOverlays) {\n    //     mapRef.current.createSegmentOverlays(contextMenu.feature, mapRef);\n    //   }\n    //   setContextMenu({ ...contextMenu, visible: false });\n\n    //   addHistoryAction({\n    //     type: 'delete-vertex',\n    //     featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\n    //     prevCoords,\n    //     newCoords,\n    //     index: contextMenu.index\n    //   });\n\n    // }\n    if (action === 'delete-vertex') {\n      const prevCoords = cloneCoords(coords);\n      const newCoords = cloneCoords(coords);\n      newCoords.splice(contextMenu.index, 1);\n      if (geom.getType() === 'Polygon') {\n        // Only delete if at least 4 points remain (3 + closing point)\n        if (newCoords.length < 4) {\n          showModal = true;\n          modalMessage = 'Cannot delete vertex: at least 3 points required for a polygon';\n          return;\n        }\n        newCoords[newCoords.length - 1] = newCoords[0]; // close ring\n        geom.setCoordinates([newCoords]);\n      } else if (geom.getType() === 'LineString') {\n        // Only delete if at least 2 points remain (minimum for a line)\n        if (newCoords.length < 2) return;\n        geom.setCoordinates(newCoords);\n      } else {\n        return;\n      }\n      if (mapRef.current && mapRef.current.createSegmentOverlays) {\n        mapRef.current.createSegmentOverlays(contextMenu.feature, mapRef);\n      }\n      setContextMenu({\n        ...contextMenu,\n        visible: false\n      });\n      addHistoryAction({\n        type: 'delete-vertex',\n        featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\n        prevCoords,\n        newCoords,\n        index: contextMenu.index,\n        geomType: geom.getType()\n      });\n    }\n    if (action === 'delete-segment') {\n      if (clearOverlaysProp) clearOverlaysProp(contextMenu.feature);\n      const prevCoords = cloneCoords(coords);\n      if (geom.getType() === 'Polygon') {\n        if (coords.length > 3 && coords[0][0] === coords[coords.length - 1][0] && coords[0][1] === coords[coords.length - 1][1]) {\n          coords = coords.slice(0, coords.length - 1);\n        }\n        const index = contextMenu.index;\n        const part1 = coords.slice(index + 1);\n        const part2 = coords.slice(0, index + 1);\n        const newCoords = [...part1, ...part2];\n        if (vectorSourceRef.current && vectorSourceRef.current.getFeatures().includes(contextMenu.feature)) {\n          vectorSourceRef.current.removeFeature(contextMenu.feature);\n        }\n        const lineFeature = new Feature(new LineString(newCoords));\n        if (contextMenu.feature.getId) {\n          lineFeature.setId(contextMenu.feature.getId());\n        }\n        vectorSourceRef.current.addFeature(lineFeature);\n        if (mapRef.current && mapRef.current.createSegmentOverlays) {\n          mapRef.current.createSegmentOverlays(lineFeature, mapRef);\n        }\n        setContextMenu({\n          ...contextMenu,\n          visible: false\n        });\n        addHistoryAction({\n          type: 'delete-segment',\n          featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\n          prevCoords,\n          newCoords: cloneCoords(newCoords),\n          index: contextMenu.index,\n          geomType: 'Polygon'\n        });\n      } else if (geom.getType() === 'LineString') {\n        // Only allow if at least 3 points (2 segments)\n        if (coords.length < 3) return;\n        const index = contextMenu.index;\n        // Remove the endpoint after the segment index\n        const newCoords = cloneCoords(coords);\n        newCoords.splice(index + 1, 1);\n        geom.setCoordinates(newCoords);\n        if (mapRef.current && mapRef.current.createSegmentOverlays) {\n          mapRef.current.createSegmentOverlays(contextMenu.feature, mapRef);\n        }\n        setContextMenu({\n          ...contextMenu,\n          visible: false\n        });\n        addHistoryAction({\n          type: 'delete-segment',\n          featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\n          prevCoords,\n          newCoords: cloneCoords(newCoords),\n          index: contextMenu.index,\n          geomType: 'LineString'\n        });\n      }\n    }\n    // if (action === 'delete-segment' && coords.length > 3) {\n    //   if (clearOverlaysProp) clearOverlaysProp(contextMenu.feature);\n    //   const prevCoords = cloneCoords(coords);\n    //   if (\n    //     coords.length > 2 &&\n    //     coords[0][0] === coords[coords.length - 1][0] &&\n    //     coords[0][1] === coords[coords.length - 1][1]\n    //   ) {\n    //     coords = coords.slice(0, coords.length - 1);\n    //   }\n    //   const index = contextMenu.index;\n    //   const part1 = coords.slice(index + 1);\n    //   const part2 = coords.slice(0, index + 1);\n    //   const newCoords = [...part1, ...part2];\n\n    //   if (vectorSourceRef.current && vectorSourceRef.current.getFeatures().includes(contextMenu.feature)) {\n    //     vectorSourceRef.current.removeFeature(contextMenu.feature);\n    //   }\n    //   const lineFeature = new Feature(new LineString(newCoords));\n    //   if (contextMenu.feature.getId) {\n    //     lineFeature.setId(contextMenu.feature.getId());\n    //   }\n    //   vectorSourceRef.current.addFeature(lineFeature);\n\n    //   if (mapRef.current && mapRef.current.createSegmentOverlays) {\n    //     mapRef.current.createSegmentOverlays(lineFeature, mapRef);\n    //   }\n    //   setContextMenu({ ...contextMenu, visible: false });\n\n    //   addHistoryAction({\n    //     type: 'delete-segment',\n    //     featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\n    //     prevCoords,\n    //     newCoords: cloneCoords(newCoords),\n    //     index: contextMenu.index\n    //   });\n\n    // }\n  };\n  return;\n  /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(Modal, {\n      open: modal.open,\n      message: modal.message,\n      onClose: () => setModal({\n        open: false,\n        message: ''\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 280,\n      columnNumber: 5\n    }, this), contextMenu.visible ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"right-click-menu\",\n      style: {\n        position: 'fixed',\n        top: contextMenu.y,\n        left: contextMenu.x,\n        background: '#fff',\n        border: '1px solid #ccc',\n        zIndex: 1000,\n        padding: 4,\n        minWidth: 120\n      },\n      onContextMenu: e => e.preventDefault(),\n      onMouseLeave: () => setContextMenu({\n        ...contextMenu,\n        visible: false\n      }),\n      children: contextMenu.type === 'vertex' ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"menu-item\",\n        onClick: () => handleMenuAction('delete-vertex'),\n        style: {\n          cursor: 'pointer',\n          padding: '4px 8px'\n        },\n        children: \"Delete Vertex\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 301,\n        columnNumber: 11\n      }, this) : contextMenu.type === 'segment' && !drawing ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"menu-item\",\n        onClick: () => handleMenuAction('delete-segment'),\n        style: {\n          cursor: 'pointer',\n          padding: '4px 8px'\n        },\n        children: \"Delete Segment\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 310,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          color: '#888',\n          padding: '4px 8px'\n        },\n        children: \"No actions\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 318,\n        columnNumber: 14\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 286,\n      columnNumber: 7\n    }, this) : null]\n  }, void 0, true);\n};\n_s(RightClick, \"3ubReDTFssvu4DHeldAg55cW/CI=\");\n_c = RightClick;\nexport default RightClick;\nvar _c;\n$RefreshReg$(_c, \"RightClick\");","map":{"version":3,"names":["React","useEffect","Feature","LineString","Modal","jsxDEV","_jsxDEV","Fragment","_Fragment","showModal","modalMessage","RightClick","mapRef","vectorSourceRef","contextMenu","setContextMenu","clearPolygonOverlays","clearOverlaysProp","addHistoryAction","drawing","_s","handleCustomContextMenu","e","mapDiv","document","getElementById","current","contains","target","preventDefault","pixel","getEventPixel","features","getFeatures","found","feature","geom","getGeometry","coords","getType","getCoordinates","len","length","i","coordPixel","getPixelFromCoordinate","Math","hypot","visible","x","clientX","y","clientY","type","index","c1","c2","t","proj","addEventListener","removeEventListener","hideMenu","menu","window","cloneCoords","map","c","Array","isArray","handleMenuAction","action","arr","prevCoords","newCoords","splice","setCoordinates","createSegmentOverlays","featureId","getId","geomType","slice","part1","part2","includes","removeFeature","lineFeature","setId","addFeature","children","open","modal","message","onClose","setModal","fileName","_jsxFileName","lineNumber","columnNumber","className","style","position","top","left","background","border","zIndex","padding","minWidth","onContextMenu","onMouseLeave","onClick","cursor","color","_c","$RefreshReg$"],"sources":["C:/Users/ncarl/Desktop/sketch/openlayers-react-map/src/map-actions/RightClick.jsx"],"sourcesContent":["import React, { useEffect } from 'react';\r\nimport { Feature } from 'ol';\r\nimport LineString from 'ol/geom/LineString';\r\nimport Modal from '../map-helpers/Modal';\r\n\r\nlet showModal = false;\r\nlet modalMessage = '';\r\n\r\nconst RightClick = ({\r\n  mapRef,\r\n  vectorSourceRef,\r\n  contextMenu,\r\n  setContextMenu,\r\n  clearPolygonOverlays: clearOverlaysProp,\r\n  addHistoryAction,\r\n  drawing\r\n}) => {\r\n  useEffect(() => {\r\n    function handleCustomContextMenu(e) {\r\n      const mapDiv = document.getElementById('map');\r\n      if (!mapDiv || !mapRef.current || !vectorSourceRef.current) return;\r\n      if (!mapDiv.contains(e.target)) return;\r\n      e.preventDefault();\r\n      const pixel = mapRef.current.getEventPixel(e);\r\n      const features = vectorSourceRef.current.getFeatures();\r\n\r\n      let found = false;\r\n      for (const feature of features) {\r\n        const geom = feature.getGeometry();\r\n        let coords = null;\r\n        if (geom.getType() === 'Polygon') {\r\n          coords = geom.getCoordinates()[0];\r\n        } else if (geom.getType() === 'LineString') {\r\n          coords = geom.getCoordinates();\r\n        }\r\n        if (coords) {\r\n          // For polygons, skip last duplicate point\r\n          const len = geom.getType() === 'Polygon' ? coords.length - 1 : coords.length;\r\n          for (let i = 0; i < len; i++) {\r\n            const coordPixel = mapRef.current.getPixelFromCoordinate(coords[i]);\r\n            if (Math.hypot(pixel[0] - coordPixel[0], pixel[1] - coordPixel[1]) < 8) {\r\n              setContextMenu({ visible: true, x: e.clientX, y: e.clientY, type: 'vertex', feature, index: i });\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (found) break;\r\n      }\r\n\r\n      if (!found) {\r\n        for (const feature of features) {\r\n          const geom = feature.getGeometry();\r\n          let coords = null;\r\n          if (geom.getType() === 'Polygon') {\r\n            coords = geom.getCoordinates()[0];\r\n          } else if (geom.getType() === 'LineString') {\r\n            coords = geom.getCoordinates();\r\n          }\r\n          if (coords) {\r\n            // For polygons, skip last duplicate point\r\n            const len = geom.getType() === 'Polygon' ? coords.length - 1 : coords.length - 1;\r\n            for (let i = 0; i < len; i++) {\r\n              const c1 = mapRef.current.getPixelFromCoordinate(coords[i]);\r\n              const c2 = mapRef.current.getPixelFromCoordinate(coords[i + 1]);\r\n              const t = ((pixel[0] - c1[0]) * (c2[0] - c1[0]) + (pixel[1] - c1[1]) * (c2[1] - c1[1])) /\r\n                ((c2[0] - c1[0]) ** 2 + (c2[1] - c1[1]) ** 2);\r\n              if (t >= 0 && t <= 1) {\r\n                const proj = [c1[0] + t * (c2[0] - c1[0]), c1[1] + t * (c2[1] - c1[1])];\r\n                if (Math.hypot(pixel[0] - proj[0], pixel[1] - proj[1]) < 8) {\r\n                  setContextMenu({ visible: true, x: e.clientX, y: e.clientY, type: 'segment', feature, index: i });\r\n                  found = true;\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (found) break;\r\n        }\r\n      }\r\n\r\n      if (!found) setContextMenu({ visible: true, x: e.clientX, y: e.clientY, type: null, feature: null, index: null });\r\n    }\r\n\r\n    document.addEventListener('contextmenu', handleCustomContextMenu);\r\n    return () => document.removeEventListener('contextmenu', handleCustomContextMenu);\r\n  }, [mapRef, vectorSourceRef, setContextMenu]);\r\n\r\n  useEffect(() => {\r\n    function hideMenu() {\r\n      setContextMenu(menu => menu.visible ? { ...menu, visible: false } : menu);\r\n    }\r\n    window.addEventListener('click', hideMenu);\r\n    return () => window.removeEventListener('click', hideMenu);\r\n  }, [setContextMenu]);\r\n\r\n  // Helper to deep clone coordinates\r\n  const cloneCoords = coords => coords.map(c => Array.isArray(c) ? [...c] : c);\r\n\r\n  const handleMenuAction = (action) => {\r\n    if (!contextMenu.feature) return;\r\n    const geom = contextMenu.feature.getGeometry();\r\n    let coords;\r\n    if (geom.getType() === 'Polygon') {\r\n      const arr = geom.getCoordinates()[0];\r\n      if (!Array.isArray(arr) || arr.length < 3 || !Array.isArray(arr[0])) return;\r\n      coords = arr.map(c => [c[0], c[1]]);\r\n    } else if (geom.getType() === 'LineString') {\r\n      const arr = geom.getCoordinates();\r\n      if (!Array.isArray(arr) || arr.length < 2 || !Array.isArray(arr[0])) return;\r\n      coords = arr.map(c => [c[0], c[1]]);\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    // if (action === 'delete-vertex' && coords.length > 3) {\r\n    //   const prevCoords = cloneCoords(coords);\r\n    //   const newCoords = cloneCoords(coords);\r\n    //   newCoords.splice(contextMenu.index, 1);\r\n    //   newCoords[newCoords.length - 1] = newCoords[0];\r\n    //   geom.setCoordinates([newCoords]);\r\n    //   if (mapRef.current && mapRef.current.createSegmentOverlays) {\r\n    //     mapRef.current.createSegmentOverlays(contextMenu.feature, mapRef);\r\n    //   }\r\n    //   setContextMenu({ ...contextMenu, visible: false });\r\n\r\n    //   addHistoryAction({\r\n    //     type: 'delete-vertex',\r\n    //     featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\r\n    //     prevCoords,\r\n    //     newCoords,\r\n    //     index: contextMenu.index\r\n    //   });\r\n\r\n    // }\r\n    if (action === 'delete-vertex') {\r\n      const prevCoords = cloneCoords(coords);\r\n      const newCoords = cloneCoords(coords);\r\n      newCoords.splice(contextMenu.index, 1);\r\n\r\n      if (geom.getType() === 'Polygon') {\r\n        // Only delete if at least 4 points remain (3 + closing point)\r\n        if (newCoords.length < 4) {\r\n          showModal = true;\r\n          modalMessage = 'Cannot delete vertex: at least 3 points required for a polygon';\r\n          return;\r\n        }\r\n        newCoords[newCoords.length - 1] = newCoords[0]; // close ring\r\n        geom.setCoordinates([newCoords]);\r\n      } else if (geom.getType() === 'LineString') {\r\n        // Only delete if at least 2 points remain (minimum for a line)\r\n        if (newCoords.length < 2) return;\r\n        geom.setCoordinates(newCoords);\r\n      } else {\r\n        return;\r\n      }\r\n\r\n      if (mapRef.current && mapRef.current.createSegmentOverlays) {\r\n        mapRef.current.createSegmentOverlays(contextMenu.feature, mapRef);\r\n      }\r\n      setContextMenu({ ...contextMenu, visible: false });\r\n\r\n      addHistoryAction({\r\n        type: 'delete-vertex',\r\n        featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\r\n        prevCoords,\r\n        newCoords,\r\n        index: contextMenu.index,\r\n        geomType: geom.getType()\r\n      });\r\n    }\r\n\r\n    if (action === 'delete-segment') {\r\n      if (clearOverlaysProp) clearOverlaysProp(contextMenu.feature);\r\n      const prevCoords = cloneCoords(coords);\r\n\r\n      if (geom.getType() === 'Polygon') {\r\n        if (\r\n          coords.length > 3 &&\r\n          coords[0][0] === coords[coords.length - 1][0] &&\r\n          coords[0][1] === coords[coords.length - 1][1]\r\n        ) {\r\n          coords = coords.slice(0, coords.length - 1);\r\n        }\r\n        const index = contextMenu.index;\r\n        const part1 = coords.slice(index + 1);\r\n        const part2 = coords.slice(0, index + 1);\r\n        const newCoords = [...part1, ...part2];\r\n\r\n        if (vectorSourceRef.current && vectorSourceRef.current.getFeatures().includes(contextMenu.feature)) {\r\n          vectorSourceRef.current.removeFeature(contextMenu.feature);\r\n        }\r\n        const lineFeature = new Feature(new LineString(newCoords));\r\n        if (contextMenu.feature.getId) {\r\n          lineFeature.setId(contextMenu.feature.getId());\r\n        }\r\n        vectorSourceRef.current.addFeature(lineFeature);\r\n\r\n        if (mapRef.current && mapRef.current.createSegmentOverlays) {\r\n          mapRef.current.createSegmentOverlays(lineFeature, mapRef);\r\n        }\r\n        setContextMenu({ ...contextMenu, visible: false });\r\n\r\n        addHistoryAction({\r\n          type: 'delete-segment',\r\n          featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\r\n          prevCoords,\r\n          newCoords: cloneCoords(newCoords),\r\n          index: contextMenu.index,\r\n          geomType: 'Polygon'\r\n        });\r\n\r\n      } else if (geom.getType() === 'LineString') {\r\n        // Only allow if at least 3 points (2 segments)\r\n        if (coords.length < 3) return;\r\n        const index = contextMenu.index;\r\n        // Remove the endpoint after the segment index\r\n        const newCoords = cloneCoords(coords);\r\n        newCoords.splice(index + 1, 1);\r\n\r\n        geom.setCoordinates(newCoords);\r\n\r\n        if (mapRef.current && mapRef.current.createSegmentOverlays) {\r\n          mapRef.current.createSegmentOverlays(contextMenu.feature, mapRef);\r\n        }\r\n        setContextMenu({ ...contextMenu, visible: false });\r\n\r\n        addHistoryAction({\r\n          type: 'delete-segment',\r\n          featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\r\n          prevCoords,\r\n          newCoords: cloneCoords(newCoords),\r\n          index: contextMenu.index,\r\n          geomType: 'LineString'\r\n        });\r\n      }\r\n    }\r\n    // if (action === 'delete-segment' && coords.length > 3) {\r\n    //   if (clearOverlaysProp) clearOverlaysProp(contextMenu.feature);\r\n    //   const prevCoords = cloneCoords(coords);\r\n    //   if (\r\n    //     coords.length > 2 &&\r\n    //     coords[0][0] === coords[coords.length - 1][0] &&\r\n    //     coords[0][1] === coords[coords.length - 1][1]\r\n    //   ) {\r\n    //     coords = coords.slice(0, coords.length - 1);\r\n    //   }\r\n    //   const index = contextMenu.index;\r\n    //   const part1 = coords.slice(index + 1);\r\n    //   const part2 = coords.slice(0, index + 1);\r\n    //   const newCoords = [...part1, ...part2];\r\n\r\n    //   if (vectorSourceRef.current && vectorSourceRef.current.getFeatures().includes(contextMenu.feature)) {\r\n    //     vectorSourceRef.current.removeFeature(contextMenu.feature);\r\n    //   }\r\n    //   const lineFeature = new Feature(new LineString(newCoords));\r\n    //   if (contextMenu.feature.getId) {\r\n    //     lineFeature.setId(contextMenu.feature.getId());\r\n    //   }\r\n    //   vectorSourceRef.current.addFeature(lineFeature);\r\n\r\n    //   if (mapRef.current && mapRef.current.createSegmentOverlays) {\r\n    //     mapRef.current.createSegmentOverlays(lineFeature, mapRef);\r\n    //   }\r\n    //   setContextMenu({ ...contextMenu, visible: false });\r\n\r\n    //   addHistoryAction({\r\n    //     type: 'delete-segment',\r\n    //     featureId: contextMenu.feature.getId && contextMenu.feature.getId(),\r\n    //     prevCoords,\r\n    //     newCoords: cloneCoords(newCoords),\r\n    //     index: contextMenu.index\r\n    //   });\r\n\r\n    // }\r\n  };\r\n\r\n  return\r\n  <>\r\n    <Modal\r\n      open={modal.open}\r\n      message={modal.message}\r\n      onClose={() => setModal({ open: false, message: '' })}\r\n    />\r\n    {contextMenu.visible ? (\r\n      <div className=\"right-click-menu\"\r\n        style={{\r\n          position: 'fixed',\r\n          top: contextMenu.y,\r\n          left: contextMenu.x,\r\n          background: '#fff',\r\n          border: '1px solid #ccc',\r\n          zIndex: 1000,\r\n          padding: 4,\r\n          minWidth: 120\r\n        }}\r\n        onContextMenu={e => e.preventDefault()}\r\n        onMouseLeave={() => setContextMenu({ ...contextMenu, visible: false })}\r\n      >\r\n        {contextMenu.type === 'vertex' ? (\r\n          <div\r\n            className=\"menu-item\"\r\n            onClick={() => handleMenuAction('delete-vertex')}\r\n            style={{ cursor: 'pointer', padding: '4px 8px' }}\r\n          >\r\n            Delete Vertex\r\n          </div>\r\n        ) :\r\n          contextMenu.type === 'segment' && !drawing ? (\r\n            <div\r\n              className=\"menu-item\"\r\n              onClick={() => handleMenuAction('delete-segment')}\r\n              style={{ cursor: 'pointer', padding: '4px 8px' }}\r\n            >\r\n              Delete Segment\r\n            </div>\r\n          ) :\r\n            (<div style={{ color: '#888', padding: '4px 8px' }}>No actions</div>)}\r\n      </div>\r\n    ) : null}\r\n  </>\r\n};\r\n\r\nexport default RightClick;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}