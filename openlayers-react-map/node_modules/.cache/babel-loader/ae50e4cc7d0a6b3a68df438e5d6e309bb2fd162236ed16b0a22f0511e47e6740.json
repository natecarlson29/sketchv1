{"ast":null,"code":"import LineString from'ol/geom/LineString';import Overlay from'ol/Overlay';// Format length in feet or miles\nexport function formatLength(line){const lengthMeters=line.getLength?line.getLength():0;const lengthFeet=lengthMeters*3.28084;return lengthFeet>5280?(lengthFeet/5280).toFixed(2)+' mi':lengthFeet.toFixed(2)+\"'\";}// Remove all overlays for a feature (Polygon or LineString)\nexport function clearPolygonOverlays(feature,mapRef){if(feature&&feature._segmentOverlays){feature._segmentOverlays.forEach(overlay=>{if(mapRef&&mapRef.current)mapRef.current.removeOverlay(overlay);});feature._segmentOverlays=[];}}export function createSegmentOverlays(feature,mapRef){if(feature.get('no-measurements'))return;clearPolygonOverlays(feature,mapRef);const DIM_OFFSET=17;feature._segmentOverlays=[];const geom=feature.getGeometry();const geomType=geom.getType();let points;if(geomType==='Polygon'){points=geom.getCoordinates()[0];}else if(geomType==='LineString'){points=geom.getCoordinates();}else{return;}// --- Segment Length Overlays ---\nfor(let i=1;i<points.length;i++){const c1=points[i-1];const c2=points[i];const line=new LineString([c1,c2]);const length=formatLength(line);// Calculate perpendicular offset direction (in screen pixels)\nconst pixel1=mapRef.current.getPixelFromCoordinate(c1);const pixel2=mapRef.current.getPixelFromCoordinate(c2);const dx=pixel2[0]-pixel1[0];const dy=pixel2[1]-pixel1[1];const len=Math.sqrt(dx*dx+dy*dy);const perp=len===0?[0,0]:[dy/len,-(dx/len)];// Offset midpoint in screen pixels\nconst offsetMidPixel=[(pixel1[0]+pixel2[0])/2+perp[0]*DIM_OFFSET,(pixel1[1]+pixel2[1])/2+perp[1]*DIM_OFFSET];const offsetMidCoord=mapRef.current.getCoordinateFromPixel(offsetMidPixel);// Place the tooltip at the offset position\nconst tooltip=document.createElement('div');tooltip.className='segment-tooltip';tooltip.innerHTML=length;tooltip.style.transform='none';const overlay=new Overlay({element:tooltip,position:offsetMidCoord,positioning:'center-center',stopEvent:false});mapRef.current.addOverlay(overlay);feature._segmentOverlays.push(overlay);}// --- Vertex Angle Overlays ---\nconst isPolygon=geomType==='Polygon';const n=points.length;if(isPolygon){// For polygons, skip the last point (duplicate of the first)\nfor(let i=0;i<n-1;i++){const prev=points[(i-1+n-1)%(n-1)];const curr=points[i];const next=points[(i+1)%(n-1)];const angle=getVertexAngle(prev,curr,next);if(angle===null||isNaN(angle)||angle===90)continue;const pixelCurr=mapRef.current.getPixelFromCoordinate(curr);const pixelPrev=mapRef.current.getPixelFromCoordinate(prev);const pixelNext=mapRef.current.getPixelFromCoordinate(next);// Bisector direction for offset\nconst bisector=[pixelPrev[0]-pixelCurr[0]+(pixelNext[0]-pixelCurr[0]),pixelPrev[1]-pixelCurr[1]+(pixelNext[1]-pixelCurr[1])];const bisLen=Math.sqrt(bisector[0]*bisector[0]+bisector[1]*bisector[1])||1;const offsetPixel=[pixelCurr[0]+bisector[0]/bisLen*(DIM_OFFSET*0.8),pixelCurr[1]+bisector[1]/bisLen*(DIM_OFFSET*0.8)];const offsetCoord=mapRef.current.getCoordinateFromPixel(offsetPixel);const angleTooltip=document.createElement('div');angleTooltip.className='segment-tooltip angle-tooltip';angleTooltip.innerHTML=\"\".concat(angle.toFixed(1),\"\\xB0\");angleTooltip.style.transform='none';const angleOverlay=new Overlay({element:angleTooltip,position:offsetCoord,positioning:'center-center',stopEvent:false});mapRef.current.addOverlay(angleOverlay);feature._segmentOverlays.push(angleOverlay);}}else{// For lines, show angle at each interior vertex (not endpoints)\nfor(let i=1;i<n-1;i++){const prev=points[i-1];const curr=points[i];const next=points[i+1];const angle=getVertexAngle(prev,curr,next);if(angle===null||isNaN(angle)||angle===90)continue;const pixelCurr=mapRef.current.getPixelFromCoordinate(curr);const pixelPrev=mapRef.current.getPixelFromCoordinate(prev);const pixelNext=mapRef.current.getPixelFromCoordinate(next);const bisector=[pixelPrev[0]-pixelCurr[0]+(pixelNext[0]-pixelCurr[0]),pixelPrev[1]-pixelCurr[1]+(pixelNext[1]-pixelCurr[1])];const bisLen=Math.sqrt(bisector[0]*bisector[0]+bisector[1]*bisector[1])||1;const offsetPixel=[pixelCurr[0]+bisector[0]/bisLen*(DIM_OFFSET*0.8),pixelCurr[1]+bisector[1]/bisLen*(DIM_OFFSET*0.8)];const offsetCoord=mapRef.current.getCoordinateFromPixel(offsetPixel);const angleTooltip=document.createElement('div');angleTooltip.className='segment-tooltip angle-tooltip';angleTooltip.innerHTML=\"\".concat(angle.toFixed(1),\"\\xB0\");angleTooltip.style.transform='none';const angleOverlay=new Overlay({element:angleTooltip,position:offsetCoord,positioning:'center-center',stopEvent:false});mapRef.current.addOverlay(angleOverlay);feature._segmentOverlays.push(angleOverlay);}}}// Helper to calculate the angle at a vertex (in degrees)\nfunction getVertexAngle(prev,curr,next){if(!prev||!curr||!next)return null;const v1=[prev[0]-curr[0],prev[1]-curr[1]];const v2=[next[0]-curr[0],next[1]-curr[1]];const dot=v1[0]*v2[0]+v1[1]*v2[1];const len1=Math.sqrt(v1[0]*v1[0]+v1[1]*v1[1]);const len2=Math.sqrt(v2[0]*v2[0]+v2[1]*v2[1]);if(len1===0||len2===0)return null;let angleRad=Math.acos(dot/(len1*len2));return angleRad*180/Math.PI;}// Calculate distance from a point to a line segment defined by two points\nexport function pointToSegmentDistance(p,p1,p2){const x=p[0],y=p[1];const x1=p1[0],y1=p1[1];const x2=p2[0],y2=p2[1];const A=x-x1;const B=y-y1;const C=x2-x1;const D=y2-y1;const dot=A*C+B*D;const len_sq=C*C+D*D;let param=-1;if(len_sq!==0)param=dot/len_sq;let xx,yy;if(param<0){xx=x1;yy=y1;}else if(param>1){xx=x2;yy=y2;}else{xx=x1+param*C;yy=y1+param*D;}const dx=x-xx;const dy=y-yy;return Math.sqrt(dx*dx+dy*dy);}// createSegmentOverlays (no angles)\n// export function createSegmentOverlays(feature, mapRef) {\n//   clearPolygonOverlays(feature, mapRef);\n//   const DIM_OFFSET = 17;\n//   feature._segmentOverlays = [];\n//   const geom = feature.getGeometry();\n//   const geomType = geom.getType();\n//   let points;\n//   if (geomType === 'Polygon') {\n//     points = geom.getCoordinates()[0];\n//   } else if (geomType === 'LineString') {\n//     points = geom.getCoordinates();\n//   } else {\n//     return;\n//   }\n//   for (let i = 1; i < points.length; i++) {\n//     const c1 = points[i - 1];\n//     const c2 = points[i];\n//     const line = new LineString([c1, c2]);\n//     const length = formatLength(line);\n//     // Calculate perpendicular offset direction (in screen pixels)\n//     const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\n//     const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\n//     const dx = pixel2[0] - pixel1[0];\n//     const dy = pixel2[1] - pixel1[1];\n//     const len = Math.sqrt(dx * dx + dy * dy);\n//     const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\n//     // Offset midpoint in screen pixels\n//     const offsetMidPixel = [\n//       (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\n//       (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\n//     ];\n//     const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\n//     // Place the tooltip at the offset position\n//     const tooltip = document.createElement('div');\n//     tooltip.className = 'segment-tooltip';\n//     tooltip.innerHTML = length;\n//     // Always keep the tooltip horizontal, regardless of map rotation\n//     tooltip.style.transform = 'none';\n//     const overlay = new Overlay({\n//       element: tooltip,\n//       position: offsetMidCoord,\n//       positioning: 'center-center',\n//       stopEvent: false,\n//     });\n//     mapRef.current.addOverlay(overlay);\n//     feature._segmentOverlays.push(overlay);\n//   }\n// }","map":{"version":3,"names":["LineString","Overlay","formatLength","line","lengthMeters","getLength","lengthFeet","toFixed","clearPolygonOverlays","feature","mapRef","_segmentOverlays","forEach","overlay","current","removeOverlay","createSegmentOverlays","get","DIM_OFFSET","geom","getGeometry","geomType","getType","points","getCoordinates","i","length","c1","c2","pixel1","getPixelFromCoordinate","pixel2","dx","dy","len","Math","sqrt","perp","offsetMidPixel","offsetMidCoord","getCoordinateFromPixel","tooltip","document","createElement","className","innerHTML","style","transform","element","position","positioning","stopEvent","addOverlay","push","isPolygon","n","prev","curr","next","angle","getVertexAngle","isNaN","pixelCurr","pixelPrev","pixelNext","bisector","bisLen","offsetPixel","offsetCoord","angleTooltip","concat","angleOverlay","v1","v2","dot","len1","len2","angleRad","acos","PI","pointToSegmentDistance","p","p1","p2","x","y","x1","y1","x2","y2","A","B","C","D","len_sq","param","xx","yy"],"sources":["C:/Users/ncarl/Desktop/sketch/openlayers-react-map/src/map-helpers/Measurements.js"],"sourcesContent":["import LineString from 'ol/geom/LineString';\r\nimport Overlay from 'ol/Overlay';\r\n\r\n// Format length in feet or miles\r\nexport function formatLength(line) {\r\n  const lengthMeters = line.getLength ? line.getLength() : 0;\r\n  const lengthFeet = lengthMeters * 3.28084;\r\n  return lengthFeet > 5280\r\n    ? (lengthFeet / 5280).toFixed(2) + ' mi'\r\n    : lengthFeet.toFixed(2) + \"'\";\r\n}\r\n\r\n// Remove all overlays for a feature (Polygon or LineString)\r\nexport function clearPolygonOverlays(feature, mapRef) {\r\n  if (feature && feature._segmentOverlays) {\r\n    feature._segmentOverlays.forEach(overlay => {\r\n      if (mapRef && mapRef.current) mapRef.current.removeOverlay(overlay);\r\n    });\r\n    feature._segmentOverlays = [];\r\n  }\r\n}\r\n\r\nexport function createSegmentOverlays(feature, mapRef) {\r\n  if (feature.get('no-measurements')) return;\r\n  clearPolygonOverlays(feature, mapRef);\r\n  const DIM_OFFSET = 17;\r\n  feature._segmentOverlays = [];\r\n\r\n  const geom = feature.getGeometry();\r\n  const geomType = geom.getType();\r\n  let points;\r\n\r\n  if (geomType === 'Polygon') {\r\n    points = geom.getCoordinates()[0];\r\n  } else if (geomType === 'LineString') {\r\n    points = geom.getCoordinates();\r\n  } else {\r\n    return;\r\n  }\r\n\r\n  // --- Segment Length Overlays ---\r\n  for (let i = 1; i < points.length; i++) {\r\n    const c1 = points[i - 1];\r\n    const c2 = points[i];\r\n    const line = new LineString([c1, c2]);\r\n    const length = formatLength(line);\r\n\r\n    // Calculate perpendicular offset direction (in screen pixels)\r\n    const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\r\n    const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\r\n    const dx = pixel2[0] - pixel1[0];\r\n    const dy = pixel2[1] - pixel1[1];\r\n    const len = Math.sqrt(dx * dx + dy * dy);\r\n    const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\r\n\r\n    // Offset midpoint in screen pixels\r\n    const offsetMidPixel = [\r\n      (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\r\n      (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\r\n    ];\r\n    const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\r\n\r\n    // Place the tooltip at the offset position\r\n    const tooltip = document.createElement('div');\r\n    tooltip.className = 'segment-tooltip';\r\n    tooltip.innerHTML = length;\r\n    tooltip.style.transform = 'none';\r\n\r\n    const overlay = new Overlay({\r\n      element: tooltip,\r\n      position: offsetMidCoord,\r\n      positioning: 'center-center',\r\n      stopEvent: false,\r\n    });\r\n    mapRef.current.addOverlay(overlay);\r\n    feature._segmentOverlays.push(overlay);\r\n  }\r\n\r\n  // --- Vertex Angle Overlays ---\r\n  const isPolygon = geomType === 'Polygon';\r\n  const n = points.length;\r\n  if (isPolygon) {\r\n    // For polygons, skip the last point (duplicate of the first)\r\n    for (let i = 0; i < n - 1; i++) {\r\n      const prev = points[(i - 1 + n - 1) % (n - 1)];\r\n      const curr = points[i];\r\n      const next = points[(i + 1) % (n - 1)];\r\n\r\n      const angle = getVertexAngle(prev, curr, next);\r\n      if (angle === null || isNaN(angle) || angle === 90) continue;\r\n\r\n      const pixelCurr = mapRef.current.getPixelFromCoordinate(curr);\r\n      const pixelPrev = mapRef.current.getPixelFromCoordinate(prev);\r\n      const pixelNext = mapRef.current.getPixelFromCoordinate(next);\r\n\r\n      // Bisector direction for offset\r\n      const bisector = [\r\n        (pixelPrev[0] - pixelCurr[0]) + (pixelNext[0] - pixelCurr[0]),\r\n        (pixelPrev[1] - pixelCurr[1]) + (pixelNext[1] - pixelCurr[1])\r\n      ];\r\n      const bisLen = Math.sqrt(bisector[0] * bisector[0] + bisector[1] * bisector[1]) || 1;\r\n      const offsetPixel = [\r\n        pixelCurr[0] + (bisector[0] / bisLen) * (DIM_OFFSET * 0.8),\r\n        pixelCurr[1] + (bisector[1] / bisLen) * (DIM_OFFSET * 0.8)\r\n      ];\r\n      const offsetCoord = mapRef.current.getCoordinateFromPixel(offsetPixel);\r\n\r\n      const angleTooltip = document.createElement('div');\r\n      angleTooltip.className = 'segment-tooltip angle-tooltip';\r\n      angleTooltip.innerHTML = `${angle.toFixed(1)}°`;\r\n      angleTooltip.style.transform = 'none';\r\n\r\n      const angleOverlay = new Overlay({\r\n        element: angleTooltip,\r\n        position: offsetCoord,\r\n        positioning: 'center-center',\r\n        stopEvent: false,\r\n      });\r\n      mapRef.current.addOverlay(angleOverlay);\r\n      feature._segmentOverlays.push(angleOverlay);\r\n    }\r\n  } else {\r\n    // For lines, show angle at each interior vertex (not endpoints)\r\n    for (let i = 1; i < n - 1; i++) {\r\n      const prev = points[i - 1];\r\n      const curr = points[i];\r\n      const next = points[i + 1];\r\n\r\n      const angle = getVertexAngle(prev, curr, next);\r\n      if (angle === null || isNaN(angle) || angle === 90) continue;\r\n\r\n      const pixelCurr = mapRef.current.getPixelFromCoordinate(curr);\r\n      const pixelPrev = mapRef.current.getPixelFromCoordinate(prev);\r\n      const pixelNext = mapRef.current.getPixelFromCoordinate(next);\r\n\r\n      const bisector = [\r\n        (pixelPrev[0] - pixelCurr[0]) + (pixelNext[0] - pixelCurr[0]),\r\n        (pixelPrev[1] - pixelCurr[1]) + (pixelNext[1] - pixelCurr[1])\r\n      ];\r\n      const bisLen = Math.sqrt(bisector[0] * bisector[0] + bisector[1] * bisector[1]) || 1;\r\n      const offsetPixel = [\r\n        pixelCurr[0] + (bisector[0] / bisLen) * (DIM_OFFSET * 0.8),\r\n        pixelCurr[1] + (bisector[1] / bisLen) * (DIM_OFFSET * 0.8)\r\n      ];\r\n      const offsetCoord = mapRef.current.getCoordinateFromPixel(offsetPixel);\r\n\r\n      const angleTooltip = document.createElement('div');\r\n      angleTooltip.className = 'segment-tooltip angle-tooltip';\r\n      angleTooltip.innerHTML = `${angle.toFixed(1)}°`;\r\n      angleTooltip.style.transform = 'none';\r\n\r\n      const angleOverlay = new Overlay({\r\n        element: angleTooltip,\r\n        position: offsetCoord,\r\n        positioning: 'center-center',\r\n        stopEvent: false,\r\n      });\r\n      mapRef.current.addOverlay(angleOverlay);\r\n      feature._segmentOverlays.push(angleOverlay);\r\n    }\r\n  }\r\n}\r\n\r\n// Helper to calculate the angle at a vertex (in degrees)\r\nfunction getVertexAngle(prev, curr, next) {\r\n  if (!prev || !curr || !next) return null;\r\n  const v1 = [prev[0] - curr[0], prev[1] - curr[1]];\r\n  const v2 = [next[0] - curr[0], next[1] - curr[1]];\r\n  const dot = v1[0] * v2[0] + v1[1] * v2[1];\r\n  const len1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);\r\n  const len2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);\r\n  if (len1 === 0 || len2 === 0) return null;\r\n  let angleRad = Math.acos(dot / (len1 * len2));\r\n  return (angleRad * 180) / Math.PI;\r\n}\r\n\r\n// Calculate distance from a point to a line segment defined by two points\r\nexport function pointToSegmentDistance(p, p1, p2) {\r\n  const x = p[0], y = p[1];\r\n  const x1 = p1[0], y1 = p1[1];\r\n  const x2 = p2[0], y2 = p2[1];\r\n  const A = x - x1;\r\n  const B = y - y1;\r\n  const C = x2 - x1;\r\n  const D = y2 - y1;\r\n\r\n  const dot = A * C + B * D;\r\n  const len_sq = C * C + D * D;\r\n  let param = -1;\r\n  if (len_sq !== 0) param = dot / len_sq;\r\n\r\n  let xx, yy;\r\n  if (param < 0) {\r\n    xx = x1;\r\n    yy = y1;\r\n  } else if (param > 1) {\r\n    xx = x2;\r\n    yy = y2;\r\n  } else {\r\n    xx = x1 + param * C;\r\n    yy = y1 + param * D;\r\n  }\r\n\r\n  const dx = x - xx;\r\n  const dy = y - yy;\r\n  return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\n// createSegmentOverlays (no angles)\r\n// export function createSegmentOverlays(feature, mapRef) {\r\n//   clearPolygonOverlays(feature, mapRef);\r\n//   const DIM_OFFSET = 17;\r\n//   feature._segmentOverlays = [];\r\n\r\n//   const geom = feature.getGeometry();\r\n//   const geomType = geom.getType();\r\n//   let points;\r\n\r\n//   if (geomType === 'Polygon') {\r\n//     points = geom.getCoordinates()[0];\r\n//   } else if (geomType === 'LineString') {\r\n//     points = geom.getCoordinates();\r\n//   } else {\r\n//     return;\r\n//   }\r\n\r\n//   for (let i = 1; i < points.length; i++) {\r\n//     const c1 = points[i - 1];\r\n//     const c2 = points[i];\r\n//     const line = new LineString([c1, c2]);\r\n//     const length = formatLength(line);\r\n\r\n//     // Calculate perpendicular offset direction (in screen pixels)\r\n//     const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\r\n//     const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\r\n//     const dx = pixel2[0] - pixel1[0];\r\n//     const dy = pixel2[1] - pixel1[1];\r\n//     const len = Math.sqrt(dx * dx + dy * dy);\r\n//     const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\r\n\r\n//     // Offset midpoint in screen pixels\r\n//     const offsetMidPixel = [\r\n//       (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\r\n//       (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\r\n//     ];\r\n//     const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\r\n\r\n//     // Place the tooltip at the offset position\r\n//     const tooltip = document.createElement('div');\r\n//     tooltip.className = 'segment-tooltip';\r\n//     tooltip.innerHTML = length;\r\n\r\n//     // Always keep the tooltip horizontal, regardless of map rotation\r\n//     tooltip.style.transform = 'none';\r\n\r\n//     const overlay = new Overlay({\r\n//       element: tooltip,\r\n//       position: offsetMidCoord,\r\n//       positioning: 'center-center',\r\n//       stopEvent: false,\r\n//     });\r\n//     mapRef.current.addOverlay(overlay);\r\n//     feature._segmentOverlays.push(overlay);\r\n//   }\r\n// }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}