{"ast":null,"code":"/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  var xResolution = getWidth(maxExtent) / viewportSize[0];\n  var yResolution = getHeight(maxExtent) / viewportSize[1];\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  var result = Math.min(resolution, maxResolution);\n  var ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var maxResolution = resolutions[0];\n        var minResolution = resolutions[resolutions.length - 1];\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        var capped = Math.min(cappedMaxRes, resolution);\n        var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          var smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        var tolerance = 1e-9;\n        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n        var offset = -direction * (0.5 - tolerance) + 0.5;\n        var capped = Math.min(cappedMaxRes, resolution);\n        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        var newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n        var smooth = opt_smooth !== undefined ? opt_smooth : true;\n        if (!smooth || !opt_isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}","map":{"version":3,"names":["clamp","getHeight","getWidth","linearFindNearest","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","Math","min","max","getSmoothClampedResolution","maxResolution","minResolution","result","ratio","log","createSnapToResolutions","resolutions","opt_smooth","opt_maxExtent","opt_showFullExtent","direction","size","opt_isMoving","undefined","length","cappedMaxRes","smooth","capped","z","floor","createSnapToPower","power","opt_minResolution","tolerance","minZoomLevel","ceil","offset","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\resolutionconstraint.js"],"sourcesContent":["/**\n * @module ol/resolutionconstraint\n */\nimport {clamp} from './math.js';\nimport {getHeight, getWidth} from './extent.js';\nimport {linearFindNearest} from './array.js';\n\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(\n  resolution,\n  maxExtent,\n  viewportSize,\n  showFullExtent\n) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n\n  result *=\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n    1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /=\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n        ratio +\n      1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(\n  resolutions,\n  opt_smooth,\n  opt_maxExtent,\n  opt_showFullExtent\n) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = opt_maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              opt_maxExtent,\n              size,\n              opt_showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          const smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(\n  power,\n  maxResolution,\n  opt_minResolution,\n  opt_smooth,\n  opt_maxExtent,\n  opt_showFullExtent\n) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = opt_maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              opt_maxExtent,\n              size,\n              opt_showFullExtent\n            )\n          : maxResolution;\n        const minResolution =\n          opt_minResolution !== undefined ? opt_minResolution : 0;\n\n        // during interacting or animating, allow intermediary values\n        if (opt_isMoving) {\n          const smooth = opt_smooth !== undefined ? opt_smooth : true;\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance\n        );\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(\n          Math.log(maxResolution / capped) / Math.log(power) + offset\n        );\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(\n  maxResolution,\n  minResolution,\n  opt_smooth,\n  opt_maxExtent,\n  opt_showFullExtent\n) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = opt_maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              opt_maxExtent,\n              size,\n              opt_showFullExtent\n            )\n          : maxResolution;\n        const smooth = opt_smooth !== undefined ? opt_smooth : true;\n\n        if (!smooth || !opt_isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(\n          resolution,\n          cappedMaxRes,\n          minResolution\n        );\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}