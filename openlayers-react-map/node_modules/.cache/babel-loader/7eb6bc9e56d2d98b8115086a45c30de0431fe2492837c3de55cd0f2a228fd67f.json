{"ast":null,"code":"/**\n * @module ol/interaction/DragAndDrop\n */\n// FIXME should handle all geo-referenced data, not just vector data\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Interaction from './Interaction.js';\nimport { TRUE } from '../functions.js';\nimport { get as getProjection } from '../proj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Options\n * @property {Array<typeof import(\"../format/Feature.js\").default|import(\"../format/Feature.js\").default>} [formatConstructors] Format constructors\n * (and/or formats pre-constructed with options).\n * @property {import(\"../source/Vector.js\").default} [source] Optional vector source where features will be added.  If a source is provided\n * all existing features will be removed and new features will be added when\n * they are dropped on the target.  If you want to add features to a vector\n * source without removing the existing features (append only), instead of\n * providing the source option listen for the \"addfeatures\" event.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\n * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.\n */\n/**\n * @enum {string}\n */\nvar DragAndDropEventType = {\n  /**\n   * Triggered when features are added\n   * @event DragAndDropEvent#addfeatures\n   * @api\n   */\n  ADD_FEATURES: 'addfeatures'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\n * of this type.\n */\nvar DragAndDropEvent = /** @class */function (_super) {\n  __extends(DragAndDropEvent, _super);\n  /**\n   * @param {DragAndDropEventType} type Type.\n   * @param {File} file File.\n   * @param {Array<import(\"../Feature.js\").default>} [opt_features] Features.\n   * @param {import(\"../proj/Projection.js\").default} [opt_projection] Projection.\n   */\n  function DragAndDropEvent(type, file, opt_features, opt_projection) {\n    var _this = _super.call(this, type) || this;\n    /**\n     * The features parsed from dropped data.\n     * @type {Array<import(\"../Feature.js\").FeatureLike>|undefined}\n     * @api\n     */\n    _this.features = opt_features;\n    /**\n     * The dropped file.\n     * @type {File}\n     * @api\n     */\n    _this.file = file;\n    /**\n     * The feature projection.\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     * @api\n     */\n    _this.projection = opt_projection;\n    return _this;\n  }\n  return DragAndDropEvent;\n}(Event);\nexport { DragAndDropEvent };\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'addfeatures', DragAndDropEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature\n */\n/**\n * @classdesc\n * Handles input of vector data by drag and drop.\n *\n * Note that the DragAndDrop interaction uses the TextDecoder() constructor if the supplied\n * combination of formats read both text string and ArrayBuffer sources. Older browsers such\n * as IE which do not support this will need a TextDecoder polyfill to be loaded before use.\n *\n * @api\n *\n * @fires DragAndDropEvent\n */\nvar DragAndDrop = /** @class */function (_super) {\n  __extends(DragAndDrop, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  function DragAndDrop(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      handleEvent: TRUE\n    }) || this;\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n    _this.on;\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n    _this.once;\n    /***\n     * @type {DragAndDropOnSignature<void>}\n     */\n    _this.un;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.readAsBuffer_ = false;\n    /**\n     * @private\n     * @type {Array<import(\"../format/Feature.js\").default>}\n     */\n    _this.formats_ = [];\n    var formatConstructors = options.formatConstructors ? options.formatConstructors : [];\n    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {\n      var format = formatConstructors[i];\n      if (typeof format === 'function') {\n        format = new format();\n      }\n      _this.formats_.push(format);\n      _this.readAsBuffer_ = _this.readAsBuffer_ || format.getType() === 'arraybuffer';\n    }\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    _this.projection_ = options.projection ? getProjection(options.projection) : null;\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.dropListenKeys_ = null;\n    /**\n     * @private\n     * @type {import(\"../source/Vector.js\").default}\n     */\n    _this.source_ = options.source || null;\n    /**\n     * @private\n     * @type {HTMLElement|null}\n     */\n    _this.target = options.target ? options.target : null;\n    return _this;\n  }\n  /**\n   * @param {File} file File.\n   * @param {Event} event Load event.\n   * @private\n   */\n  DragAndDrop.prototype.handleResult_ = function (file, event) {\n    var result = event.target.result;\n    var map = this.getMap();\n    var projection = this.projection_;\n    if (!projection) {\n      var view = map.getView();\n      projection = view.getProjection();\n    }\n    var text;\n    var formats = this.formats_;\n    for (var i = 0, ii = formats.length; i < ii; ++i) {\n      var format = formats[i];\n      var input = result;\n      if (this.readAsBuffer_ && format.getType() !== 'arraybuffer') {\n        if (text === undefined) {\n          text = new TextDecoder().decode(result);\n        }\n        input = text;\n      }\n      var features = this.tryReadFeatures_(format, input, {\n        featureProjection: projection\n      });\n      if (features && features.length > 0) {\n        if (this.source_) {\n          this.source_.clear();\n          this.source_.addFeatures(features);\n        }\n        this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));\n        break;\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  DragAndDrop.prototype.registerListeners_ = function () {\n    var map = this.getMap();\n    if (map) {\n      var dropArea = this.target ? this.target : map.getViewport();\n      this.dropListenKeys_ = [listen(dropArea, EventType.DROP, this.handleDrop, this), listen(dropArea, EventType.DRAGENTER, this.handleStop, this), listen(dropArea, EventType.DRAGOVER, this.handleStop, this), listen(dropArea, EventType.DROP, this.handleStop, this)];\n    }\n  };\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  DragAndDrop.prototype.setActive = function (active) {\n    if (!this.getActive() && active) {\n      this.registerListeners_();\n    }\n    if (this.getActive() && !active) {\n      this.unregisterListeners_();\n    }\n    _super.prototype.setActive.call(this, active);\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  DragAndDrop.prototype.setMap = function (map) {\n    this.unregisterListeners_();\n    _super.prototype.setMap.call(this, map);\n    if (this.getActive()) {\n      this.registerListeners_();\n    }\n  };\n  /**\n   * @param {import(\"../format/Feature.js\").default} format Format.\n   * @param {string} text Text.\n   * @param {import(\"../format/Feature.js\").ReadOptions} options Read options.\n   * @private\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  DragAndDrop.prototype.tryReadFeatures_ = function (format, text, options) {\n    try {\n      return /** @type {Array<import(\"../Feature.js\").default>} */format.readFeatures(text, options);\n    } catch (e) {\n      return null;\n    }\n  };\n  /**\n   * @private\n   */\n  DragAndDrop.prototype.unregisterListeners_ = function () {\n    if (this.dropListenKeys_) {\n      this.dropListenKeys_.forEach(unlistenByKey);\n      this.dropListenKeys_ = null;\n    }\n  };\n  /**\n   * @param {DragEvent} event Event.\n   */\n  DragAndDrop.prototype.handleDrop = function (event) {\n    var files = event.dataTransfer.files;\n    for (var i = 0, ii = files.length; i < ii; ++i) {\n      var file = files.item(i);\n      var reader = new FileReader();\n      reader.addEventListener(EventType.LOAD, this.handleResult_.bind(this, file));\n      if (this.readAsBuffer_) {\n        reader.readAsArrayBuffer(file);\n      } else {\n        reader.readAsText(file);\n      }\n    }\n  };\n  /**\n   * @param {DragEvent} event Event.\n   */\n  DragAndDrop.prototype.handleStop = function (event) {\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'copy';\n  };\n  return DragAndDrop;\n}(Interaction);\nexport default DragAndDrop;","map":{"version":3,"names":["Event","EventType","Interaction","TRUE","get","getProjection","listen","unlistenByKey","DragAndDropEventType","ADD_FEATURES","DragAndDropEvent","_super","__extends","type","file","opt_features","opt_projection","_this","call","features","projection","DragAndDrop","opt_options","options","handleEvent","on","once","un","readAsBuffer_","formats_","formatConstructors","i","ii","length","format","push","getType","projection_","dropListenKeys_","source_","source","target","prototype","handleResult_","event","result","map","getMap","view","getView","text","formats","input","undefined","TextDecoder","decode","tryReadFeatures_","featureProjection","clear","addFeatures","dispatchEvent","registerListeners_","dropArea","getViewport","DROP","handleDrop","DRAGENTER","handleStop","DRAGOVER","setActive","active","getActive","unregisterListeners_","setMap","readFeatures","e","forEach","files","dataTransfer","item","reader","FileReader","addEventListener","LOAD","bind","readAsArrayBuffer","readAsText","stopPropagation","preventDefault","dropEffect"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\interaction\\DragAndDrop.js"],"sourcesContent":["/**\n * @module ol/interaction/DragAndDrop\n */\n// FIXME should handle all geo-referenced data, not just vector data\n\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Interaction from './Interaction.js';\nimport {TRUE} from '../functions.js';\nimport {get as getProjection} from '../proj.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Options\n * @property {Array<typeof import(\"../format/Feature.js\").default|import(\"../format/Feature.js\").default>} [formatConstructors] Format constructors\n * (and/or formats pre-constructed with options).\n * @property {import(\"../source/Vector.js\").default} [source] Optional vector source where features will be added.  If a source is provided\n * all existing features will be removed and new features will be added when\n * they are dropped on the target.  If you want to add features to a vector\n * source without removing the existing features (append only), instead of\n * providing the source option listen for the \"addfeatures\" event.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.\n * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.\n */\n\n/**\n * @enum {string}\n */\nconst DragAndDropEventType = {\n  /**\n   * Triggered when features are added\n   * @event DragAndDropEvent#addfeatures\n   * @api\n   */\n  ADD_FEATURES: 'addfeatures',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances\n * of this type.\n */\nexport class DragAndDropEvent extends Event {\n  /**\n   * @param {DragAndDropEventType} type Type.\n   * @param {File} file File.\n   * @param {Array<import(\"../Feature.js\").default>} [opt_features] Features.\n   * @param {import(\"../proj/Projection.js\").default} [opt_projection] Projection.\n   */\n  constructor(type, file, opt_features, opt_projection) {\n    super(type);\n\n    /**\n     * The features parsed from dropped data.\n     * @type {Array<import(\"../Feature.js\").FeatureLike>|undefined}\n     * @api\n     */\n    this.features = opt_features;\n\n    /**\n     * The dropped file.\n     * @type {File}\n     * @api\n     */\n    this.file = file;\n\n    /**\n     * The feature projection.\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     * @api\n     */\n    this.projection = opt_projection;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'addfeatures', DragAndDropEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature\n */\n\n/**\n * @classdesc\n * Handles input of vector data by drag and drop.\n *\n * Note that the DragAndDrop interaction uses the TextDecoder() constructor if the supplied\n * combination of formats read both text string and ArrayBuffer sources. Older browsers such\n * as IE which do not support this will need a TextDecoder polyfill to be loaded before use.\n *\n * @api\n *\n * @fires DragAndDropEvent\n */\nclass DragAndDrop extends Interaction {\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    super({\n      handleEvent: TRUE,\n    });\n\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DragAndDropOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DragAndDropOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.readAsBuffer_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../format/Feature.js\").default>}\n     */\n    this.formats_ = [];\n    const formatConstructors = options.formatConstructors\n      ? options.formatConstructors\n      : [];\n    for (let i = 0, ii = formatConstructors.length; i < ii; ++i) {\n      let format = formatConstructors[i];\n      if (typeof format === 'function') {\n        format = new format();\n      }\n      this.formats_.push(format);\n      this.readAsBuffer_ =\n        this.readAsBuffer_ || format.getType() === 'arraybuffer';\n    }\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.projection_ = options.projection\n      ? getProjection(options.projection)\n      : null;\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.dropListenKeys_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../source/Vector.js\").default}\n     */\n    this.source_ = options.source || null;\n\n    /**\n     * @private\n     * @type {HTMLElement|null}\n     */\n    this.target = options.target ? options.target : null;\n  }\n\n  /**\n   * @param {File} file File.\n   * @param {Event} event Load event.\n   * @private\n   */\n  handleResult_(file, event) {\n    const result = event.target.result;\n    const map = this.getMap();\n    let projection = this.projection_;\n    if (!projection) {\n      const view = map.getView();\n      projection = view.getProjection();\n    }\n\n    let text;\n    const formats = this.formats_;\n    for (let i = 0, ii = formats.length; i < ii; ++i) {\n      const format = formats[i];\n      let input = result;\n      if (this.readAsBuffer_ && format.getType() !== 'arraybuffer') {\n        if (text === undefined) {\n          text = new TextDecoder().decode(result);\n        }\n        input = text;\n      }\n      const features = this.tryReadFeatures_(format, input, {\n        featureProjection: projection,\n      });\n      if (features && features.length > 0) {\n        if (this.source_) {\n          this.source_.clear();\n          this.source_.addFeatures(features);\n        }\n        this.dispatchEvent(\n          new DragAndDropEvent(\n            DragAndDropEventType.ADD_FEATURES,\n            file,\n            features,\n            projection\n          )\n        );\n        break;\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  registerListeners_() {\n    const map = this.getMap();\n    if (map) {\n      const dropArea = this.target ? this.target : map.getViewport();\n      this.dropListenKeys_ = [\n        listen(dropArea, EventType.DROP, this.handleDrop, this),\n        listen(dropArea, EventType.DRAGENTER, this.handleStop, this),\n        listen(dropArea, EventType.DRAGOVER, this.handleStop, this),\n        listen(dropArea, EventType.DROP, this.handleStop, this),\n      ];\n    }\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    if (!this.getActive() && active) {\n      this.registerListeners_();\n    }\n    if (this.getActive() && !active) {\n      this.unregisterListeners_();\n    }\n    super.setActive(active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  setMap(map) {\n    this.unregisterListeners_();\n    super.setMap(map);\n    if (this.getActive()) {\n      this.registerListeners_();\n    }\n  }\n\n  /**\n   * @param {import(\"../format/Feature.js\").default} format Format.\n   * @param {string} text Text.\n   * @param {import(\"../format/Feature.js\").ReadOptions} options Read options.\n   * @private\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  tryReadFeatures_(format, text, options) {\n    try {\n      return (\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        (format.readFeatures(text, options))\n      );\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * @private\n   */\n  unregisterListeners_() {\n    if (this.dropListenKeys_) {\n      this.dropListenKeys_.forEach(unlistenByKey);\n      this.dropListenKeys_ = null;\n    }\n  }\n\n  /**\n   * @param {DragEvent} event Event.\n   */\n  handleDrop(event) {\n    const files = event.dataTransfer.files;\n    for (let i = 0, ii = files.length; i < ii; ++i) {\n      const file = files.item(i);\n      const reader = new FileReader();\n      reader.addEventListener(\n        EventType.LOAD,\n        this.handleResult_.bind(this, file)\n      );\n      if (this.readAsBuffer_) {\n        reader.readAsArrayBuffer(file);\n      } else {\n        reader.readAsText(file);\n      }\n    }\n  }\n\n  /**\n   * @param {DragEvent} event Event.\n   */\n  handleStop(event) {\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'copy';\n  }\n}\n\nexport default DragAndDrop;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}