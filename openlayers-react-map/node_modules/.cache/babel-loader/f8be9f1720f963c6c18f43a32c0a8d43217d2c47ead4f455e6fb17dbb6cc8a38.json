{"ast":null,"code":"/**\r\n * Checks if two coordinates are equal.\r\n */\nexport function coordsEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\r\n * Finds the closest coordinate in all features to the pointerPixel within a tolerance.\r\n */\nexport function getSnappedCoordinate(map, vectorSource, pointerPixel, tolerance = 25) {\n  let closestCoord = null;\n  let minDist = Infinity;\n  vectorSource.getFeatures().forEach(feature => {\n    const geom = feature.getGeometry();\n    let coords = [];\n    if (geom.getType() === 'Polygon') {\n      coords = geom.getCoordinates()[0];\n    } else if (geom.getType() === 'LineString') {\n      coords = geom.getCoordinates();\n    }\n    coords.forEach(coord => {\n      const pixel = map.getPixelFromCoordinate(coord);\n      const dist = Math.hypot(pointerPixel[0] - pixel[0], pointerPixel[1] - pixel[1]);\n      if (dist < minDist && dist < tolerance) {\n        minDist = dist;\n        closestCoord = coord;\n      }\n    });\n  });\n  return closestCoord;\n}\n\n/**\r\n * Custom snapping for translate interaction.\r\n * Only snaps the entire feature to other feature edges (not vertices).\r\n * Keeps the geometry rigid.\r\n */\nexport function customSnapFeature(feature, vectorSource, map, tolerance = 10) {\n  const geom = feature.getGeometry();\n  if (!geom) return;\n\n  // Get all other features\n  const otherFeatures = vectorSource.getFeatures().filter(f => f !== feature);\n\n  // Get all vertices of the moving feature\n  let coords = [];\n  if (geom.getType() === 'Polygon') {\n    coords = geom.getCoordinates()[0];\n  } else if (geom.getType() === 'LineString') {\n    coords = geom.getCoordinates();\n  }\n  let snapOffset = null;\n\n  // For each vertex in the moving feature\n  for (let i = 0; i < coords.length; i++) {\n    const vertex = coords[i];\n    const vertexPixel = map.getPixelFromCoordinate(vertex);\n    for (const other of otherFeatures) {\n      const otherGeom = other.getGeometry();\n      let otherCoords = [];\n      if (otherGeom.getType() === 'Polygon') {\n        otherCoords = otherGeom.getCoordinates()[0];\n      } else if (otherGeom.getType() === 'LineString') {\n        otherCoords = otherGeom.getCoordinates();\n      }\n\n      // Snap only to edges (not vertices)\n      for (let j = 0; j < otherCoords.length - 1; j++) {\n        const segStart = otherCoords[j];\n        const segEnd = otherCoords[j + 1];\n        // Project vertex onto segment\n        const snapped = snapPointToSegment(vertex, segStart, segEnd);\n        const snappedPixel = map.getPixelFromCoordinate(snapped);\n        const dist = Math.hypot(vertexPixel[0] - snappedPixel[0], vertexPixel[1] - snappedPixel[1]);\n        if (dist < tolerance) {\n          // Calculate offset needed to snap the whole feature\n          snapOffset = [snapped[0] - vertex[0], snapped[1] - vertex[1]];\n          break;\n        }\n      }\n      if (snapOffset) break;\n    }\n    if (snapOffset) break;\n  }\n\n  // If a snap is needed, move the entire feature by the offset\n  if (snapOffset) {\n    const newCoords = coords.map(([x, y]) => [x + snapOffset[0], y + snapOffset[1]]);\n    if (geom.getType() === 'Polygon') {\n      geom.setCoordinates([newCoords]);\n    } else if (geom.getType() === 'LineString') {\n      geom.setCoordinates(newCoords);\n    }\n  }\n}\n\n/**\r\n * Projects a point onto a segment and returns the closest point on the segment.\r\n */\nexport function snapPointToSegment(pt, segA, segB) {\n  const [x, y] = pt;\n  const [x1, y1] = segA;\n  const [x2, y2] = segB;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  if (dx === 0 && dy === 0) return segA.slice();\n  const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n  if (t < 0) return segA.slice();\n  if (t > 1) return segB.slice();\n  return [x1 + t * dx, y1 + t * dy];\n}","map":{"version":3,"names":["coordsEqual","a","b","getSnappedCoordinate","map","vectorSource","pointerPixel","tolerance","closestCoord","minDist","Infinity","getFeatures","forEach","feature","geom","getGeometry","coords","getType","getCoordinates","coord","pixel","getPixelFromCoordinate","dist","Math","hypot","customSnapFeature","otherFeatures","filter","f","snapOffset","i","length","vertex","vertexPixel","other","otherGeom","otherCoords","j","segStart","segEnd","snapped","snapPointToSegment","snappedPixel","newCoords","x","y","setCoordinates","pt","segA","segB","x1","y1","x2","y2","dx","dy","slice","t"],"sources":["C:/Users/ncarl/Desktop/sketch/openlayers-react-map/src/map-helpers/Snapping.js"],"sourcesContent":["/**\r\n * Checks if two coordinates are equal.\r\n */\r\nexport function coordsEqual(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1];\r\n}\r\n\r\n/**\r\n * Finds the closest coordinate in all features to the pointerPixel within a tolerance.\r\n */\r\nexport function getSnappedCoordinate(map, vectorSource, pointerPixel, tolerance = 25) {\r\n  let closestCoord = null;\r\n  let minDist = Infinity;\r\n\r\n  vectorSource.getFeatures().forEach(feature => {\r\n    const geom = feature.getGeometry();\r\n    let coords = [];\r\n    if (geom.getType() === 'Polygon') {\r\n      coords = geom.getCoordinates()[0];\r\n    } else if (geom.getType() === 'LineString') {\r\n      coords = geom.getCoordinates();\r\n    }\r\n    coords.forEach(coord => {\r\n      const pixel = map.getPixelFromCoordinate(coord);\r\n      const dist = Math.hypot(pointerPixel[0] - pixel[0], pointerPixel[1] - pixel[1]);\r\n      if (dist < minDist && dist < tolerance) {\r\n        minDist = dist;\r\n        closestCoord = coord;\r\n      }\r\n    });\r\n  });\r\n\r\n  return closestCoord;\r\n}\r\n\r\n/**\r\n * Custom snapping for translate interaction.\r\n * Only snaps the entire feature to other feature edges (not vertices).\r\n * Keeps the geometry rigid.\r\n */\r\nexport function customSnapFeature(feature, vectorSource, map, tolerance = 10) {\r\n  const geom = feature.getGeometry();\r\n  if (!geom) return;\r\n\r\n  // Get all other features\r\n  const otherFeatures = vectorSource.getFeatures().filter(f => f !== feature);\r\n\r\n  // Get all vertices of the moving feature\r\n  let coords = [];\r\n  if (geom.getType() === 'Polygon') {\r\n    coords = geom.getCoordinates()[0];\r\n  } else if (geom.getType() === 'LineString') {\r\n    coords = geom.getCoordinates();\r\n  }\r\n\r\n  let snapOffset = null;\r\n\r\n  // For each vertex in the moving feature\r\n  for (let i = 0; i < coords.length; i++) {\r\n    const vertex = coords[i];\r\n    const vertexPixel = map.getPixelFromCoordinate(vertex);\r\n\r\n    for (const other of otherFeatures) {\r\n      const otherGeom = other.getGeometry();\r\n      let otherCoords = [];\r\n      if (otherGeom.getType() === 'Polygon') {\r\n        otherCoords = otherGeom.getCoordinates()[0];\r\n      } else if (otherGeom.getType() === 'LineString') {\r\n        otherCoords = otherGeom.getCoordinates();\r\n      }\r\n\r\n      // Snap only to edges (not vertices)\r\n      for (let j = 0; j < otherCoords.length - 1; j++) {\r\n        const segStart = otherCoords[j];\r\n        const segEnd = otherCoords[j + 1];\r\n        // Project vertex onto segment\r\n        const snapped = snapPointToSegment(vertex, segStart, segEnd);\r\n        const snappedPixel = map.getPixelFromCoordinate(snapped);\r\n        const dist = Math.hypot(vertexPixel[0] - snappedPixel[0], vertexPixel[1] - snappedPixel[1]);\r\n        if (dist < tolerance) {\r\n          // Calculate offset needed to snap the whole feature\r\n          snapOffset = [snapped[0] - vertex[0], snapped[1] - vertex[1]];\r\n          break;\r\n        }\r\n      }\r\n      if (snapOffset) break;\r\n    }\r\n    if (snapOffset) break;\r\n  }\r\n\r\n  // If a snap is needed, move the entire feature by the offset\r\n  if (snapOffset) {\r\n    const newCoords = coords.map(([x, y]) => [x + snapOffset[0], y + snapOffset[1]]);\r\n    if (geom.getType() === 'Polygon') {\r\n      geom.setCoordinates([newCoords]);\r\n    } else if (geom.getType() === 'LineString') {\r\n      geom.setCoordinates(newCoords);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Projects a point onto a segment and returns the closest point on the segment.\r\n */\r\nexport function snapPointToSegment(pt, segA, segB) {\r\n  const [x, y] = pt;\r\n  const [x1, y1] = segA;\r\n  const [x2, y2] = segB;\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  if (dx === 0 && dy === 0) return segA.slice();\r\n  const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n  if (t < 0) return segA.slice();\r\n  if (t > 1) return segB.slice();\r\n  return [x1 + t * dx, y1 + t * dy];\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}