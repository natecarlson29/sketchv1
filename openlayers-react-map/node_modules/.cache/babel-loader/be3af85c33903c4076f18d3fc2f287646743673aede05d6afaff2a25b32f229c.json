{"ast":null,"code":"/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\nimport { assert } from './asserts.js';\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n  var extent = createEmpty();\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [opt_extent] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n  var minX = Math.min.apply(null, xs);\n  var minY = Math.min.apply(null, ys);\n  var maxX = Math.max.apply(null, xs);\n  var maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n}\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0] - value;\n    opt_extent[1] = extent[1] - value;\n    opt_extent[2] = extent[2] + value;\n    opt_extent[3] = extent[3] + value;\n    return opt_extent;\n  } else {\n    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];\n  }\n}\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent.slice();\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n  var dx, dy;\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var x = coordinate[0];\n  var y = coordinate[1];\n  var relationship = Relationship.UNKNOWN;\n  if (x < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n  if (y < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n  return relationship;\n}\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = minX;\n    opt_extent[1] = minY;\n    opt_extent[2] = maxX;\n    opt_extent[3] = maxY;\n    return opt_extent;\n  } else {\n    return [minX, minY, maxX, maxY];\n  }\n}\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(opt_extent) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, opt_extent) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  return createOrUpdate(x, y, x, y, opt_extent);\n}\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendCoordinates(extent, coordinates);\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendRings(extent, rings);\n}\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];\n}\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;\n}\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n  for (var i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n  var val;\n  val = callback(getBottomLeft(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getBottomRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopLeft(extent));\n  if (val) {\n    return val;\n  }\n  return false;\n}\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n  var area = 0;\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n  return area;\n}\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n  var coordinate;\n  if (corner === 'bottom-left') {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === 'bottom-right') {\n    coordinate = getBottomRight(extent);\n  } else if (corner === 'top-left') {\n    coordinate = getTopLeft(extent);\n  } else if (corner === 'top-right') {\n    coordinate = getTopRight(extent);\n  } else {\n    assert(false, 13); // Invalid corner\n  }\n  return coordinate;\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n  var minX = Math.min(extent1[0], extent2[0]);\n  var minY = Math.min(extent1[1], extent2[1]);\n  var maxX = Math.max(extent1[2], extent2[2]);\n  var maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n  var _a = getRotatedViewport(center, resolution, rotation, size),\n    x0 = _a[0],\n    y0 = _a[1],\n    x1 = _a[2],\n    y1 = _a[3],\n    x2 = _a[4],\n    y2 = _a[5],\n    x3 = _a[6],\n    y3 = _a[7];\n  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\nexport function getRotatedViewport(center, resolution, rotation, size) {\n  var dx = resolution * size[0] / 2;\n  var dy = resolution * size[1] / 2;\n  var cosRotation = Math.cos(rotation);\n  var sinRotation = Math.sin(rotation);\n  var xCos = dx * cosRotation;\n  var xSin = dx * sinRotation;\n  var yCos = dy * cosRotation;\n  var ySin = dy * sinRotation;\n  var x = center[0];\n  var y = center[1];\n  return [x - xCos + ySin, y - xSin - yCos, x - xCos - ySin, y - xSin + yCos, x + xCos - ySin, y + xSin + yCos, x + xCos + ySin, y + xSin - yCos, x - xCos + ySin, y - xSin - yCos];\n}\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n  return extent[3] - extent[1];\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n  var intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [opt_extent] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, opt_extent) {\n  var intersection = opt_extent ? opt_extent : createEmpty();\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n  return intersection;\n}\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n  return extent[2] - extent[0];\n}\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];\n}\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent;\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);\n  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n  var intersects = false;\n  var startRel = coordinateRelationship(extent, start);\n  var endRel = coordinateRelationship(extent, end);\n  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {\n    intersects = true;\n  } else {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var startX = start[0];\n    var startY = start[1];\n    var endX = end[0];\n    var endY = end[1];\n    var slope = (endY - startY) / (endX - startX);\n    var x = void 0,\n      y = void 0;\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (!intersects && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n    if (!intersects && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (!intersects && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n  return intersects;\n}\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [opt_extent] Destination extent.\n * @param {number} [opt_stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, opt_extent, opt_stops) {\n  var coordinates = [];\n  if (opt_stops > 1) {\n    var width = extent[2] - extent[0];\n    var height = extent[3] - extent[1];\n    for (var i = 0; i < opt_stops; ++i) {\n      coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);\n    }\n  } else {\n    coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];\n  }\n  transformFn(coordinates, coordinates, 2);\n  var xs = [];\n  var ys = [];\n  for (var i = 0, l = coordinates.length; i < l; i += 2) {\n    xs.push(coordinates[i]);\n    ys.push(coordinates[i + 1]);\n  }\n  return _boundingExtentXYs(xs, ys, opt_extent);\n}\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n  var projectionExtent = projection.getExtent();\n  var center = getCenter(extent);\n  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);\n    var offset = worldsAway * worldWidth;\n    extent[0] -= offset;\n    extent[2] -= offset;\n  }\n  return extent;\n}\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */\nexport function wrapAndSliceX(extent, projection) {\n  if (projection.canWrapX()) {\n    var projectionExtent = projection.getExtent();\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n    wrapX(extent, projection);\n    var worldWidth = getWidth(projectionExtent);\n    if (getWidth(extent) > worldWidth) {\n      // the extent wraps around on itself\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    } else if (extent[0] < projectionExtent[0]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [[extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2], extent[3]]];\n    } else if (extent[2] > projectionExtent[2]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [[extent[0], extent[1], projectionExtent[2], extent[3]], [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]];\n    }\n  }\n  return [extent];\n}","map":{"version":3,"names":["Relationship","assert","boundingExtent","coordinates","extent","createEmpty","i","ii","length","extendCoordinate","_boundingExtentXYs","xs","ys","opt_extent","minX","Math","min","apply","minY","maxX","max","maxY","createOrUpdate","buffer","value","clone","slice","closestSquaredDistanceXY","x","y","dx","dy","containsCoordinate","coordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","relationship","UNKNOWN","LEFT","RIGHT","BELOW","ABOVE","INTERSECTING","Infinity","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromCoordinates","extendCoordinates","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","end","stride","extendFlatCoordinates","createOrUpdateFromRings","rings","extendRings","equals","approximatelyEquals","tolerance","abs","extend","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","isEmpty","getWidth","getHeight","getCenter","getCorner","corner","getEnlargedArea","getForViewAndSize","center","resolution","rotation","size","_a","getRotatedViewport","x0","y0","x1","y1","x2","y2","x3","y3","cosRotation","cos","sinRotation","sin","xCos","xSin","yCos","ySin","getIntersectionArea","intersection","getIntersection","intersects","getMargin","getSize","returnOrUpdate","scaleFromCenter","deltaX","deltaY","intersectsSegment","start","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","opt_stops","width","height","push","l","wrapX","projection","projectionExtent","getExtent","canWrapX","worldWidth","worldsAway","floor","wrapAndSliceX","isFinite"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\extent.js"],"sourcesContent":["/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\nimport {assert} from './asserts.js';\n\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n  const extent = createEmpty();\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [opt_extent] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n  const minX = Math.min.apply(null, xs);\n  const minY = Math.min.apply(null, ys);\n  const maxX = Math.max.apply(null, xs);\n  const maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n}\n\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0] - value;\n    opt_extent[1] = extent[1] - value;\n    opt_extent[2] = extent[2] + value;\n    opt_extent[3] = extent[3] + value;\n    return opt_extent;\n  } else {\n    return [\n      extent[0] - value,\n      extent[1] - value,\n      extent[2] + value,\n      extent[3] + value,\n    ];\n  }\n}\n\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent.slice();\n  }\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n  let dx, dy;\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[0] &&\n    extent2[2] <= extent1[2] &&\n    extent1[1] <= extent2[1] &&\n    extent2[3] <= extent1[3]\n  );\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const x = coordinate[0];\n  const y = coordinate[1];\n  let relationship = Relationship.UNKNOWN;\n  if (x < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n  if (y < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n  return relationship;\n}\n\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = minX;\n    opt_extent[1] = minY;\n    opt_extent[2] = maxX;\n    opt_extent[3] = maxY;\n    return opt_extent;\n  } else {\n    return [minX, minY, maxX, maxY];\n  }\n}\n\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(opt_extent) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, opt_extent) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  return createOrUpdate(x, y, x, y, opt_extent);\n}\n\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, opt_extent) {\n  const extent = createOrUpdateEmpty(opt_extent);\n  return extendCoordinates(extent, coordinates);\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  opt_extent\n) {\n  const extent = createOrUpdateEmpty(opt_extent);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, opt_extent) {\n  const extent = createOrUpdateEmpty(opt_extent);\n  return extendRings(extent, rings);\n}\n\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n  return (\n    extent1[0] == extent2[0] &&\n    extent1[2] == extent2[2] &&\n    extent1[1] == extent2[1] &&\n    extent1[3] == extent2[3]\n  );\n}\n\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n  return (\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\n    Math.abs(extent1[3] - extent2[3]) < tolerance\n  );\n}\n\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(\n  extent,\n  flatCoordinates,\n  offset,\n  end,\n  stride\n) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n  let val;\n  val = callback(getBottomLeft(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getBottomRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopLeft(extent));\n  if (val) {\n    return val;\n  }\n  return false;\n}\n\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n  let area = 0;\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n  return area;\n}\n\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n  let coordinate;\n  if (corner === 'bottom-left') {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === 'bottom-right') {\n    coordinate = getBottomRight(extent);\n  } else if (corner === 'top-left') {\n    coordinate = getTopLeft(extent);\n  } else if (corner === 'top-right') {\n    coordinate = getTopRight(extent);\n  } else {\n    assert(false, 13); // Invalid corner\n  }\n  return coordinate;\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n  const minX = Math.min(extent1[0], extent2[0]);\n  const minY = Math.min(extent1[1], extent2[1]);\n  const maxX = Math.max(extent1[2], extent2[2]);\n  const maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(\n  center,\n  resolution,\n  rotation,\n  size,\n  opt_extent\n) {\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\n    center,\n    resolution,\n    rotation,\n    size\n  );\n  return createOrUpdate(\n    Math.min(x0, x1, x2, x3),\n    Math.min(y0, y1, y2, y3),\n    Math.max(x0, x1, x2, x3),\n    Math.max(y0, y1, y2, y3),\n    opt_extent\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\nexport function getRotatedViewport(center, resolution, rotation, size) {\n  const dx = (resolution * size[0]) / 2;\n  const dy = (resolution * size[1]) / 2;\n  const cosRotation = Math.cos(rotation);\n  const sinRotation = Math.sin(rotation);\n  const xCos = dx * cosRotation;\n  const xSin = dx * sinRotation;\n  const yCos = dy * cosRotation;\n  const ySin = dy * sinRotation;\n  const x = center[0];\n  const y = center[1];\n  return [\n    x - xCos + ySin,\n    y - xSin - yCos,\n    x - xCos - ySin,\n    y - xSin + yCos,\n    x + xCos - ySin,\n    y + xSin + yCos,\n    x + xCos + ySin,\n    y + xSin - yCos,\n    x - xCos + ySin,\n    y - xSin - yCos,\n  ];\n}\n\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n  return extent[3] - extent[1];\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n  const intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [opt_extent] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, opt_extent) {\n  const intersection = opt_extent ? opt_extent : createEmpty();\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n  return intersection;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n  return extent[2] - extent[0];\n}\n\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[2] &&\n    extent1[2] >= extent2[0] &&\n    extent1[1] <= extent2[3] &&\n    extent1[3] >= extent2[1]\n  );\n}\n\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent;\n  }\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n  let intersects = false;\n  const startRel = coordinateRelationship(extent, start);\n  const endRel = coordinateRelationship(extent, end);\n  if (\n    startRel === Relationship.INTERSECTING ||\n    endRel === Relationship.INTERSECTING\n  ) {\n    intersects = true;\n  } else {\n    const minX = extent[0];\n    const minY = extent[1];\n    const maxX = extent[2];\n    const maxY = extent[3];\n    const startX = start[0];\n    const startY = start[1];\n    const endX = end[0];\n    const endY = end[1];\n    const slope = (endY - startY) / (endX - startX);\n    let x, y;\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.RIGHT) &&\n      !(startRel & Relationship.RIGHT)\n    ) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.BELOW) &&\n      !(startRel & Relationship.BELOW)\n    ) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.LEFT) &&\n      !(startRel & Relationship.LEFT)\n    ) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n  return intersects;\n}\n\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [opt_extent] Destination extent.\n * @param {number} [opt_stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, opt_extent, opt_stops) {\n  let coordinates = [];\n  if (opt_stops > 1) {\n    const width = extent[2] - extent[0];\n    const height = extent[3] - extent[1];\n    for (let i = 0; i < opt_stops; ++i) {\n      coordinates.push(\n        extent[0] + (width * i) / opt_stops,\n        extent[1],\n        extent[2],\n        extent[1] + (height * i) / opt_stops,\n        extent[2] - (width * i) / opt_stops,\n        extent[3],\n        extent[0],\n        extent[3] - (height * i) / opt_stops\n      );\n    }\n  } else {\n    coordinates = [\n      extent[0],\n      extent[1],\n      extent[2],\n      extent[1],\n      extent[2],\n      extent[3],\n      extent[0],\n      extent[3],\n    ];\n  }\n  transformFn(coordinates, coordinates, 2);\n  const xs = [];\n  const ys = [];\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\n    xs.push(coordinates[i]);\n    ys.push(coordinates[i + 1]);\n  }\n  return _boundingExtentXYs(xs, ys, opt_extent);\n}\n\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n  const projectionExtent = projection.getExtent();\n  const center = getCenter(extent);\n  if (\n    projection.canWrapX() &&\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\n  ) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.floor(\n      (center[0] - projectionExtent[0]) / worldWidth\n    );\n    const offset = worldsAway * worldWidth;\n    extent[0] -= offset;\n    extent[2] -= offset;\n  }\n  return extent;\n}\n\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */\nexport function wrapAndSliceX(extent, projection) {\n  if (projection.canWrapX()) {\n    const projectionExtent = projection.getExtent();\n\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n\n    wrapX(extent, projection);\n    const worldWidth = getWidth(projectionExtent);\n\n    if (getWidth(extent) > worldWidth) {\n      // the extent wraps around on itself\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    } else if (extent[0] < projectionExtent[0]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\n      ];\n    } else if (extent[2] > projectionExtent[2]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\n      ];\n    }\n  }\n\n  return [extent];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}