{"ast":null,"code":"import LineString from 'ol/geom/LineString';\nimport Overlay from 'ol/Overlay';\n\n// Format length in feet or miles\nexport function formatLength(line) {\n  const lengthMeters = line.getLength ? line.getLength() : 0;\n  const lengthFeet = lengthMeters * 3.28084;\n  return lengthFeet > 5280 ? (lengthFeet / 5280).toFixed(2) + ' mi' : lengthFeet.toFixed(2) + \"'\";\n}\n\n// Remove all overlays for a feature (Polygon or LineString)\nexport function clearPolygonOverlays(feature, mapRef) {\n  if (feature && feature._segmentOverlays) {\n    feature._segmentOverlays.forEach(overlay => {\n      if (mapRef && mapRef.current) mapRef.current.removeOverlay(overlay);\n    });\n    feature._segmentOverlays = [];\n  }\n}\n\n// export function createSegmentOverlays(feature, mapRef) {\n//   clearPolygonOverlays(feature, mapRef);\n//   const DIM_OFFSET = 17;\n//   feature._segmentOverlays = [];\n\n//   const geom = feature.getGeometry();\n//   const geomType = geom.getType();\n//   let points;\n\n//   if (geomType === 'Polygon') {\n//     points = geom.getCoordinates()[0];\n//   } else if (geomType === 'LineString') {\n//     points = geom.getCoordinates();\n//   } else {\n//     return;\n//   }\n\n//   for (let i = 1; i < points.length; i++) {\n//     const c1 = points[i - 1];\n//     const c2 = points[i];\n//     const line = new LineString([c1, c2]);\n//     const length = formatLength(line);\n\n//     // Calculate perpendicular offset direction (in screen pixels)\n//     const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\n//     const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\n//     const dx = pixel2[0] - pixel1[0];\n//     const dy = pixel2[1] - pixel1[1];\n//     const len = Math.sqrt(dx * dx + dy * dy);\n//     const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\n\n//     // Offset midpoint in screen pixels\n//     const offsetMidPixel = [\n//       (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\n//       (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\n//     ];\n//     const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\n\n//     // Place the tooltip at the offset position\n//     const tooltip = document.createElement('div');\n//     tooltip.className = 'segment-tooltip';\n//     tooltip.innerHTML = length;\n\n//     // Always keep the tooltip horizontal, regardless of map rotation\n//     tooltip.style.transform = 'none';\n\n//     const overlay = new Overlay({\n//       element: tooltip,\n//       position: offsetMidCoord,\n//       positioning: 'center-center',\n//       stopEvent: false,\n//     });\n//     mapRef.current.addOverlay(overlay);\n//     feature._segmentOverlays.push(overlay);\n//   }\n// }\n\nexport function createSegmentOverlays(feature, mapRef) {\n  clearPolygonOverlays(feature, mapRef);\n  const DIM_OFFSET = 17;\n  feature._segmentOverlays = [];\n  const geom = feature.getGeometry();\n  const geomType = geom.getType();\n  let points;\n  if (geomType === 'Polygon') {\n    points = geom.getCoordinates()[0];\n  } else if (geomType === 'LineString') {\n    points = geom.getCoordinates();\n  } else {\n    return;\n  }\n\n  // --- Segment Length Overlays ---\n  for (let i = 1; i < points.length; i++) {\n    const c1 = points[i - 1];\n    const c2 = points[i];\n    const line = new LineString([c1, c2]);\n    const length = formatLength(line);\n\n    // Calculate perpendicular offset direction (in screen pixels)\n    const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\n    const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\n    const dx = pixel2[0] - pixel1[0];\n    const dy = pixel2[1] - pixel1[1];\n    const len = Math.sqrt(dx * dx + dy * dy);\n    const perp = len === 0 ? [0, 0] : [dy / len, -(dx / len)];\n\n    // Offset midpoint in screen pixels\n    const offsetMidPixel = [(pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET, (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET];\n    const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\n\n    // Place the tooltip at the offset position\n    const tooltip = document.createElement('div');\n    tooltip.className = 'segment-tooltip';\n    tooltip.innerHTML = length;\n    tooltip.style.transform = 'none';\n    const overlay = new Overlay({\n      element: tooltip,\n      position: offsetMidCoord,\n      positioning: 'center-center',\n      stopEvent: false\n    });\n    mapRef.current.addOverlay(overlay);\n    feature._segmentOverlays.push(overlay);\n  }\n\n  // --- Vertex Angle Overlays ---\n  const isPolygon = geomType === 'Polygon';\n  const n = points.length;\n  if (isPolygon) {\n    // For polygons, skip the last point (duplicate of the first)\n    for (let i = 0; i < n - 1; i++) {\n      const prev = points[(i - 1 + n - 1) % (n - 1)];\n      const curr = points[i];\n      const next = points[(i + 1) % (n - 1)];\n      const angle = getVertexAngle(prev, curr, next);\n      if (angle === null || isNaN(angle) || angle === 90) continue;\n      const pixelCurr = mapRef.current.getPixelFromCoordinate(curr);\n      const pixelPrev = mapRef.current.getPixelFromCoordinate(prev);\n      const pixelNext = mapRef.current.getPixelFromCoordinate(next);\n\n      // Bisector direction for offset\n      const bisector = [pixelPrev[0] - pixelCurr[0] + (pixelNext[0] - pixelCurr[0]), pixelPrev[1] - pixelCurr[1] + (pixelNext[1] - pixelCurr[1])];\n      const bisLen = Math.sqrt(bisector[0] * bisector[0] + bisector[1] * bisector[1]) || 1;\n      const offsetPixel = [pixelCurr[0] + bisector[0] / bisLen * (DIM_OFFSET * 0.8), pixelCurr[1] + bisector[1] / bisLen * (DIM_OFFSET * 0.8)];\n      const offsetCoord = mapRef.current.getCoordinateFromPixel(offsetPixel);\n      const angleTooltip = document.createElement('div');\n      angleTooltip.className = 'segment-tooltip angle-tooltip';\n      angleTooltip.innerHTML = `${angle.toFixed(1)}°`;\n      angleTooltip.style.transform = 'none';\n      const angleOverlay = new Overlay({\n        element: angleTooltip,\n        position: offsetCoord,\n        positioning: 'center-center',\n        stopEvent: false\n      });\n      mapRef.current.addOverlay(angleOverlay);\n      feature._segmentOverlays.push(angleOverlay);\n    }\n  } else {\n    // For lines, show angle at each interior vertex (not endpoints)\n    for (let i = 1; i < n - 1; i++) {\n      const prev = points[i - 1];\n      const curr = points[i];\n      const next = points[i + 1];\n      const angle = getVertexAngle(prev, curr, next);\n      if (angle === null || isNaN(angle) || angle === 90) continue;\n      const pixelCurr = mapRef.current.getPixelFromCoordinate(curr);\n      const pixelPrev = mapRef.current.getPixelFromCoordinate(prev);\n      const pixelNext = mapRef.current.getPixelFromCoordinate(next);\n      const bisector = [pixelPrev[0] - pixelCurr[0] + (pixelNext[0] - pixelCurr[0]), pixelPrev[1] - pixelCurr[1] + (pixelNext[1] - pixelCurr[1])];\n      const bisLen = Math.sqrt(bisector[0] * bisector[0] + bisector[1] * bisector[1]) || 1;\n      const offsetPixel = [pixelCurr[0] + bisector[0] / bisLen * (DIM_OFFSET * 0.8), pixelCurr[1] + bisector[1] / bisLen * (DIM_OFFSET * 0.8)];\n      const offsetCoord = mapRef.current.getCoordinateFromPixel(offsetPixel);\n      const angleTooltip = document.createElement('div');\n      angleTooltip.className = 'segment-tooltip angle-tooltip';\n      angleTooltip.innerHTML = `${angle.toFixed(1)}°`;\n      angleTooltip.style.transform = 'none';\n      const angleOverlay = new Overlay({\n        element: angleTooltip,\n        position: offsetCoord,\n        positioning: 'center-center',\n        stopEvent: false\n      });\n      mapRef.current.addOverlay(angleOverlay);\n      feature._segmentOverlays.push(angleOverlay);\n    }\n  }\n}\n\n// Helper to calculate the angle at a vertex (in degrees)\nfunction getVertexAngle(prev, curr, next) {\n  if (!prev || !curr || !next) return null;\n  const v1 = [prev[0] - curr[0], prev[1] - curr[1]];\n  const v2 = [next[0] - curr[0], next[1] - curr[1]];\n  const dot = v1[0] * v2[0] + v1[1] * v2[1];\n  const len1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);\n  const len2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);\n  if (len1 === 0 || len2 === 0) return null;\n  let angleRad = Math.acos(dot / (len1 * len2));\n  return angleRad * 180 / Math.PI;\n}\n\n// Calculate distance from a point to a line segment defined by two points\nexport function pointToSegmentDistance(p, p1, p2) {\n  const x = p[0],\n    y = p[1];\n  const x1 = p1[0],\n    y1 = p1[1];\n  const x2 = p2[0],\n    y2 = p2[1];\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n  const dot = A * C + B * D;\n  const len_sq = C * C + D * D;\n  let param = -1;\n  if (len_sq !== 0) param = dot / len_sq;\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}","map":{"version":3,"names":["LineString","Overlay","formatLength","line","lengthMeters","getLength","lengthFeet","toFixed","clearPolygonOverlays","feature","mapRef","_segmentOverlays","forEach","overlay","current","removeOverlay","createSegmentOverlays","DIM_OFFSET","geom","getGeometry","geomType","getType","points","getCoordinates","i","length","c1","c2","pixel1","getPixelFromCoordinate","pixel2","dx","dy","len","Math","sqrt","perp","offsetMidPixel","offsetMidCoord","getCoordinateFromPixel","tooltip","document","createElement","className","innerHTML","style","transform","element","position","positioning","stopEvent","addOverlay","push","isPolygon","n","prev","curr","next","angle","getVertexAngle","isNaN","pixelCurr","pixelPrev","pixelNext","bisector","bisLen","offsetPixel","offsetCoord","angleTooltip","angleOverlay","v1","v2","dot","len1","len2","angleRad","acos","PI","pointToSegmentDistance","p","p1","p2","x","y","x1","y1","x2","y2","A","B","C","D","len_sq","param","xx","yy"],"sources":["C:/Users/ncarl/Desktop/sketch/openlayers-react-map/src/map-helpers/Measurements.js"],"sourcesContent":["import LineString from 'ol/geom/LineString';\r\nimport Overlay from 'ol/Overlay';\r\n\r\n// Format length in feet or miles\r\nexport function formatLength(line) {\r\n  const lengthMeters = line.getLength ? line.getLength() : 0;\r\n  const lengthFeet = lengthMeters * 3.28084;\r\n  return lengthFeet > 5280\r\n    ? (lengthFeet / 5280).toFixed(2) + ' mi'\r\n    : lengthFeet.toFixed(2) + \"'\";\r\n}\r\n\r\n// Remove all overlays for a feature (Polygon or LineString)\r\nexport function clearPolygonOverlays(feature, mapRef) {\r\n  if (feature && feature._segmentOverlays) {\r\n    feature._segmentOverlays.forEach(overlay => {\r\n      if (mapRef && mapRef.current) mapRef.current.removeOverlay(overlay);\r\n    });\r\n    feature._segmentOverlays = [];\r\n  }\r\n}\r\n\r\n// export function createSegmentOverlays(feature, mapRef) {\r\n//   clearPolygonOverlays(feature, mapRef);\r\n//   const DIM_OFFSET = 17;\r\n//   feature._segmentOverlays = [];\r\n\r\n//   const geom = feature.getGeometry();\r\n//   const geomType = geom.getType();\r\n//   let points;\r\n\r\n//   if (geomType === 'Polygon') {\r\n//     points = geom.getCoordinates()[0];\r\n//   } else if (geomType === 'LineString') {\r\n//     points = geom.getCoordinates();\r\n//   } else {\r\n//     return;\r\n//   }\r\n\r\n//   for (let i = 1; i < points.length; i++) {\r\n//     const c1 = points[i - 1];\r\n//     const c2 = points[i];\r\n//     const line = new LineString([c1, c2]);\r\n//     const length = formatLength(line);\r\n\r\n//     // Calculate perpendicular offset direction (in screen pixels)\r\n//     const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\r\n//     const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\r\n//     const dx = pixel2[0] - pixel1[0];\r\n//     const dy = pixel2[1] - pixel1[1];\r\n//     const len = Math.sqrt(dx * dx + dy * dy);\r\n//     const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\r\n\r\n//     // Offset midpoint in screen pixels\r\n//     const offsetMidPixel = [\r\n//       (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\r\n//       (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\r\n//     ];\r\n//     const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\r\n\r\n//     // Place the tooltip at the offset position\r\n//     const tooltip = document.createElement('div');\r\n//     tooltip.className = 'segment-tooltip';\r\n//     tooltip.innerHTML = length;\r\n\r\n//     // Always keep the tooltip horizontal, regardless of map rotation\r\n//     tooltip.style.transform = 'none';\r\n\r\n//     const overlay = new Overlay({\r\n//       element: tooltip,\r\n//       position: offsetMidCoord,\r\n//       positioning: 'center-center',\r\n//       stopEvent: false,\r\n//     });\r\n//     mapRef.current.addOverlay(overlay);\r\n//     feature._segmentOverlays.push(overlay);\r\n//   }\r\n// }\r\n\r\nexport function createSegmentOverlays(feature, mapRef) {\r\n  clearPolygonOverlays(feature, mapRef);\r\n  const DIM_OFFSET = 17;\r\n  feature._segmentOverlays = [];\r\n\r\n  const geom = feature.getGeometry();\r\n  const geomType = geom.getType();\r\n  let points;\r\n\r\n  if (geomType === 'Polygon') {\r\n    points = geom.getCoordinates()[0];\r\n  } else if (geomType === 'LineString') {\r\n    points = geom.getCoordinates();\r\n  } else {\r\n    return;\r\n  }\r\n\r\n  // --- Segment Length Overlays ---\r\n  for (let i = 1; i < points.length; i++) {\r\n    const c1 = points[i - 1];\r\n    const c2 = points[i];\r\n    const line = new LineString([c1, c2]);\r\n    const length = formatLength(line);\r\n\r\n    // Calculate perpendicular offset direction (in screen pixels)\r\n    const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\r\n    const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\r\n    const dx = pixel2[0] - pixel1[0];\r\n    const dy = pixel2[1] - pixel1[1];\r\n    const len = Math.sqrt(dx * dx + dy * dy);\r\n    const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\r\n\r\n    // Offset midpoint in screen pixels\r\n    const offsetMidPixel = [\r\n      (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\r\n      (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\r\n    ];\r\n    const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\r\n\r\n    // Place the tooltip at the offset position\r\n    const tooltip = document.createElement('div');\r\n    tooltip.className = 'segment-tooltip';\r\n    tooltip.innerHTML = length;\r\n    tooltip.style.transform = 'none';\r\n\r\n    const overlay = new Overlay({\r\n      element: tooltip,\r\n      position: offsetMidCoord,\r\n      positioning: 'center-center',\r\n      stopEvent: false,\r\n    });\r\n    mapRef.current.addOverlay(overlay);\r\n    feature._segmentOverlays.push(overlay);\r\n  }\r\n\r\n  // --- Vertex Angle Overlays ---\r\n  const isPolygon = geomType === 'Polygon';\r\n  const n = points.length;\r\n  if (isPolygon) {\r\n    // For polygons, skip the last point (duplicate of the first)\r\n    for (let i = 0; i < n - 1; i++) {\r\n      const prev = points[(i - 1 + n - 1) % (n - 1)];\r\n      const curr = points[i];\r\n      const next = points[(i + 1) % (n - 1)];\r\n\r\n      const angle = getVertexAngle(prev, curr, next);\r\n      if (angle === null || isNaN(angle) || angle === 90) continue;\r\n\r\n      const pixelCurr = mapRef.current.getPixelFromCoordinate(curr);\r\n      const pixelPrev = mapRef.current.getPixelFromCoordinate(prev);\r\n      const pixelNext = mapRef.current.getPixelFromCoordinate(next);\r\n\r\n      // Bisector direction for offset\r\n      const bisector = [\r\n        (pixelPrev[0] - pixelCurr[0]) + (pixelNext[0] - pixelCurr[0]),\r\n        (pixelPrev[1] - pixelCurr[1]) + (pixelNext[1] - pixelCurr[1])\r\n      ];\r\n      const bisLen = Math.sqrt(bisector[0] * bisector[0] + bisector[1] * bisector[1]) || 1;\r\n      const offsetPixel = [\r\n        pixelCurr[0] + (bisector[0] / bisLen) * (DIM_OFFSET * 0.8),\r\n        pixelCurr[1] + (bisector[1] / bisLen) * (DIM_OFFSET * 0.8)\r\n      ];\r\n      const offsetCoord = mapRef.current.getCoordinateFromPixel(offsetPixel);\r\n\r\n      const angleTooltip = document.createElement('div');\r\n      angleTooltip.className = 'segment-tooltip angle-tooltip';\r\n      angleTooltip.innerHTML = `${angle.toFixed(1)}°`;\r\n      angleTooltip.style.transform = 'none';\r\n\r\n      const angleOverlay = new Overlay({\r\n        element: angleTooltip,\r\n        position: offsetCoord,\r\n        positioning: 'center-center',\r\n        stopEvent: false,\r\n      });\r\n      mapRef.current.addOverlay(angleOverlay);\r\n      feature._segmentOverlays.push(angleOverlay);\r\n    }\r\n  } else {\r\n    // For lines, show angle at each interior vertex (not endpoints)\r\n    for (let i = 1; i < n - 1; i++) {\r\n      const prev = points[i - 1];\r\n      const curr = points[i];\r\n      const next = points[i + 1];\r\n\r\n      const angle = getVertexAngle(prev, curr, next);\r\n      if (angle === null || isNaN(angle) || angle === 90) continue;\r\n\r\n      const pixelCurr = mapRef.current.getPixelFromCoordinate(curr);\r\n      const pixelPrev = mapRef.current.getPixelFromCoordinate(prev);\r\n      const pixelNext = mapRef.current.getPixelFromCoordinate(next);\r\n\r\n      const bisector = [\r\n        (pixelPrev[0] - pixelCurr[0]) + (pixelNext[0] - pixelCurr[0]),\r\n        (pixelPrev[1] - pixelCurr[1]) + (pixelNext[1] - pixelCurr[1])\r\n      ];\r\n      const bisLen = Math.sqrt(bisector[0] * bisector[0] + bisector[1] * bisector[1]) || 1;\r\n      const offsetPixel = [\r\n        pixelCurr[0] + (bisector[0] / bisLen) * (DIM_OFFSET * 0.8),\r\n        pixelCurr[1] + (bisector[1] / bisLen) * (DIM_OFFSET * 0.8)\r\n      ];\r\n      const offsetCoord = mapRef.current.getCoordinateFromPixel(offsetPixel);\r\n\r\n      const angleTooltip = document.createElement('div');\r\n      angleTooltip.className = 'segment-tooltip angle-tooltip';\r\n      angleTooltip.innerHTML = `${angle.toFixed(1)}°`;\r\n      angleTooltip.style.transform = 'none';\r\n\r\n      const angleOverlay = new Overlay({\r\n        element: angleTooltip,\r\n        position: offsetCoord,\r\n        positioning: 'center-center',\r\n        stopEvent: false,\r\n      });\r\n      mapRef.current.addOverlay(angleOverlay);\r\n      feature._segmentOverlays.push(angleOverlay);\r\n    }\r\n  }\r\n}\r\n\r\n// Helper to calculate the angle at a vertex (in degrees)\r\nfunction getVertexAngle(prev, curr, next) {\r\n  if (!prev || !curr || !next) return null;\r\n  const v1 = [prev[0] - curr[0], prev[1] - curr[1]];\r\n  const v2 = [next[0] - curr[0], next[1] - curr[1]];\r\n  const dot = v1[0] * v2[0] + v1[1] * v2[1];\r\n  const len1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);\r\n  const len2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);\r\n  if (len1 === 0 || len2 === 0) return null;\r\n  let angleRad = Math.acos(dot / (len1 * len2));\r\n  return (angleRad * 180) / Math.PI;\r\n}\r\n\r\n// Calculate distance from a point to a line segment defined by two points\r\nexport function pointToSegmentDistance(p, p1, p2) {\r\n  const x = p[0], y = p[1];\r\n  const x1 = p1[0], y1 = p1[1];\r\n  const x2 = p2[0], y2 = p2[1];\r\n  const A = x - x1;\r\n  const B = y - y1;\r\n  const C = x2 - x1;\r\n  const D = y2 - y1;\r\n\r\n  const dot = A * C + B * D;\r\n  const len_sq = C * C + D * D;\r\n  let param = -1;\r\n  if (len_sq !== 0) param = dot / len_sq;\r\n\r\n  let xx, yy;\r\n  if (param < 0) {\r\n    xx = x1;\r\n    yy = y1;\r\n  } else if (param > 1) {\r\n    xx = x2;\r\n    yy = y2;\r\n  } else {\r\n    xx = x1 + param * C;\r\n    yy = y1 + param * D;\r\n  }\r\n\r\n  const dx = x - xx;\r\n  const dy = y - yy;\r\n  return Math.sqrt(dx * dx + dy * dy);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}