{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED } from './common.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { containsCoordinate, createEmpty, equals, getHeight, getIntersection, getRotatedViewport, getTopLeft, getWidth, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nvar CanvasTileLayerRenderer = /** @class */function (_super) {\n  __extends(CanvasTileLayerRenderer, _super);\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  function CanvasTileLayerRenderer(tileLayer) {\n    var _this = _super.call(this, tileLayer) || this;\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    _this.extentChanged = true;\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    _this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedPixelRatio;\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    _this.renderedProjection = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    _this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var tileLayer = this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  };\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  CanvasTileLayerRenderer.prototype.getData = function (pixel) {\n    var frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    var layer = this.getLayer();\n    var coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    var layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var viewState = frameState.viewState;\n    var source = layer.getRenderSource();\n    var tileGrid = source.getTileGridForProjection(viewState.projection);\n    var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n    for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n      if (!(tile instanceof ImageTile || tile instanceof ReprojTile)) {\n        return null;\n      }\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n      var tileOrigin = tileGrid.getOrigin(z);\n      var tileSize = toSize(tileGrid.getTileSize(z));\n      var tileResolution = tileGrid.getResolution(z);\n      var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n    return null;\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n    }\n    return false;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    return !!this.getLayer().getSource();\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var rotation = viewState.rotation;\n    var pixelRatio = frameState.pixelRatio;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var extent = frameState.extent;\n    var resolution = frameState.viewState.resolution;\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    var width = Math.round(getWidth(extent) / resolution * pixelRatio);\n    var height = Math.round(getHeight(extent) / resolution * pixelRatio);\n    var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n    }\n    var dx = tileResolution * width / 2 / tilePixelRatio;\n    var dy = tileResolution * height / 2 / tilePixelRatio;\n    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n          continue;\n        }\n        var tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          var uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n    var canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n    // set forward and inverse pixel transforms\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    var canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    var context = this.context;\n    var canvas = context.canvas;\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    if (!tileSource.getInterpolate()) {\n      assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var clips, clipZs, currentClip;\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (var i = zs.length - 1; i >= 0; --i) {\n      var currentZ = zs[i];\n      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      var currentResolution = tileGrid.getResolution(currentZ);\n      var currentScale = currentResolution / tileResolution;\n      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      var origin_1 = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      var tilesToDraw = tilesToDrawByZ[currentZ];\n      for (var tileCoordKey in tilesToDraw) {\n        var tile = /** @type {import(\"../../ImageTile.js\").default} */tilesToDraw[tileCoordKey];\n        var tileCoord = tile.tileCoord;\n        // Calculate integer positions and sizes so that tiles align\n        var xIndex = originTileCoord[1] - tileCoord[1];\n        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n        var yIndex = originTileCoord[2] - tileCoord[2];\n        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n        var x = Math.round(origin_1[0] - xIndex * dx_1);\n        var y = Math.round(origin_1[1] - yIndex * dy_1);\n        var w = nextX - x;\n        var h = nextY - y;\n        var transition = z === currentZ;\n        var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        var contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n              if (z !== currentZ && currentZ < clipZs[i_1]) {\n                var clip = clips[i_1];\n                if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    assign(context, IMAGE_SMOOTHING_ENABLED);\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n    return this.container;\n  };\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    var uid = getUid(this);\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    var alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  CanvasTileLayerRenderer.prototype.getImage = function () {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage();\n  };\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n      frameState.postRenderFunctions.push(/** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */postRenderFunction);\n    }\n  };\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  };\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var rotation = frameState.viewState.rotation;\n    var viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;\n    var tileCount = 0;\n    var tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  };\n  return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer);\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","ImageTile","ReprojTile","TileRange","TileState","IMAGE_SMOOTHING_DISABLED","IMAGE_SMOOTHING_ENABLED","apply","applyTransform","compose","composeTransform","makeInverse","toString","toTransformString","assign","containsCoordinate","createEmpty","equals","getHeight","getIntersection","getRotatedViewport","getTopLeft","getWidth","intersects","fromUserExtent","getUid","numberSafeCompareFunction","toSize","CanvasTileLayerRenderer","_super","__extends","tileLayer","_this","call","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","prototype","isDrawableTile","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","frameState","pixelRatio","projection","viewState","tileSource","getSource","setState","getPreload","getInterimTile","getData","pixel","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","source","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","getImage","loadedTileCallback","tiles","zoom","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","viewCenter","center","rotation","sourceRevision","getRevision","zDirection","extent","width","height","dx","dy","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","viewport","size","undefined","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","inTransition","opacity","endTransition","indexOf","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","pixelTransform","canvasTransform","useContainer","getBackground","context","canvas","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","getInterpolate","preRender","length","zs","Object","keys","map","Number","sort","clips","clipZs","currentClip","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","dx_1","dy_1","originTileCoord","originTileExtent","getTileCoordExtent","origin_1","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","i_1","ii","clip","save","beginPath","moveTo","lineTo","push","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","image","getTileImage","alpha","alphaChanged","globalAlpha","drawImage","animate","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","opt_tileCallback","wantedTiles","tileQueue","minZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\renderer\\canvas\\TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {IMAGE_SMOOTHING_DISABLED, IMAGE_SMOOTHING_ENABLED} from './common.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {assign} from '../../obj.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (!(tile instanceof ImageTile || tile instanceof ReprojTile)) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || this.renderedTiles.indexOf(tile) === -1)\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    assign(context, IMAGE_SMOOTHING_ENABLED);\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    opt_tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}