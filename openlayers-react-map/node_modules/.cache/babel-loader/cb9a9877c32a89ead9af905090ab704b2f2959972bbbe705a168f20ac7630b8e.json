{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/Point\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { containsXY, createOrUpdateFromCoordinate } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nvar Point = /** @class */function (_super) {\n  __extends(Point, _super);\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   */\n  function Point(coordinates, opt_layout) {\n    var _this = _super.call(this) || this;\n    _this.setCoordinates(coordinates, opt_layout);\n    return _this;\n  }\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @api\n   */\n  Point.prototype.clone = function () {\n    var point = new Point(this.flatCoordinates.slice(), this.layout);\n    point.applyProperties(this);\n    return point;\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\n    if (squaredDistance < minSquaredDistance) {\n      var stride = this.stride;\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @api\n   */\n  Point.prototype.getCoordinates = function () {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  Point.prototype.computeExtent = function (extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  };\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  Point.prototype.getType = function () {\n    return 'Point';\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  Point.prototype.intersectsExtent = function (extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  };\n  /**\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n  Point.prototype.setCoordinates = function (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n  return Point;\n}(SimpleGeometry);\nexport default Point;","map":{"version":3,"names":["SimpleGeometry","containsXY","createOrUpdateFromCoordinate","deflateCoordinate","squaredDistance","squaredDx","Point","_super","__extends","coordinates","opt_layout","_this","call","setCoordinates","prototype","clone","point","flatCoordinates","slice","layout","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","stride","i","length","getCoordinates","computeExtent","extent","getType","intersectsExtent","setLayout","changed"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\geom\\Point.js"],"sourcesContent":["/**\n * @module ol/geom/Point\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {containsXY, createOrUpdateFromCoordinate} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nclass Point extends SimpleGeometry {\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   */\n  constructor(coordinates, opt_layout) {\n    super();\n    this.setCoordinates(coordinates, opt_layout);\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @api\n   */\n  clone() {\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\n    point.applyProperties(this);\n    return point;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[0],\n      flatCoordinates[1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      const stride = this.stride;\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Point';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  }\n\n  /**\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default Point;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}