{"ast":null,"code":"/**\n * @module ol/geom/flat/geodesic\n */\nimport { get as getProjection, getTransform } from '../../proj.js';\nimport { squaredSegmentDistance, toDegrees, toRadians } from '../../math.js';\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n  /** @type {Array<number>} */\n  var flatCoordinates = [];\n  var geoA = interpolate(0);\n  var geoB = interpolate(1);\n  var a = transform(geoA);\n  var b = transform(geoB);\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  var geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  var stack = [b, a];\n  /** @type {Array<number>} */\n  var fractionStack = [1, 0];\n  /** @type {!Object<string, boolean>} */\n  var fractions = {};\n  var maxIterations = 1e5;\n  var geoM, m, fracA, fracB, fracM, key;\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop();\n    // Add the a coordinate if it has not been added yet\n    key = fracA.toString();\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    }\n    // Pop the b coordinate off the stack\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop();\n    // Find the m point between the a and b coordinates\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n    if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n  return flatCoordinates;\n}\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n  var geoProjection = getProjection('EPSG:4326');\n  var cosLat1 = Math.cos(toRadians(lat1));\n  var sinLat1 = Math.sin(toRadians(lat1));\n  var cosLat2 = Math.cos(toRadians(lat2));\n  var sinLat2 = Math.sin(toRadians(lat2));\n  var cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  var sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    if (1 <= d) {\n      return [lon2, lat2];\n    }\n    var D = frac * Math.acos(d);\n    var cosD = Math.cos(D);\n    var sinD = Math.sin(D);\n    var y = sinDeltaLon * cosLat2;\n    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n    var theta = Math.atan2(y, x);\n    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n    var lon = toRadians(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n  }, getTransform(geoProjection, projection), squaredTolerance);\n}\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon, lat1 + (lat2 - lat1) * frac];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon1 + (lon2 - lon1) * frac, lat];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}","map":{"version":3,"names":["get","getProjection","getTransform","squaredSegmentDistance","toDegrees","toRadians","line","interpolate","transform","squaredTolerance","flatCoordinates","geoA","geoB","a","b","geoStack","stack","fractionStack","fractions","maxIterations","geoM","m","fracA","fracB","fracM","key","length","pop","toString","push","greatCircleArc","lon1","lat1","lon2","lat2","projection","geoProjection","cosLat1","Math","cos","sinLat1","sin","cosLat2","sinLat2","cosDeltaLon","sinDeltaLon","d","frac","D","acos","cosD","sinD","y","x","theta","atan2","lat","asin","lon","meridian","epsg4326Projection","parallel"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\geom\\flat\\geodesic.js"],"sourcesContent":["/**\n * @module ol/geom/flat/geodesic\n */\nimport {get as getProjection, getTransform} from '../../proj.js';\nimport {squaredSegmentDistance, toDegrees, toRadians} from '../../math.js';\n\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n\n  let geoA = interpolate(0);\n  let geoB = interpolate(1);\n\n  let a = transform(geoA);\n  let b = transform(geoB);\n\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  const geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n  const stack = [b, a];\n  /** @type {Array<number>} */\n  const fractionStack = [1, 0];\n\n  /** @type {!Object<string, boolean>} */\n  const fractions = {};\n\n  let maxIterations = 1e5;\n  let geoM, m, fracA, fracB, fracM, key;\n\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop();\n    // Add the a coordinate if it has not been added yet\n    key = fracA.toString();\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    }\n    // Pop the b coordinate off the stack\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop();\n    // Find the m point between the a and b coordinates\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n    if (\n      squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) <\n      squaredTolerance\n    ) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n\n  return flatCoordinates;\n}\n\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function greatCircleArc(\n  lon1,\n  lat1,\n  lon2,\n  lat2,\n  projection,\n  squaredTolerance\n) {\n  const geoProjection = getProjection('EPSG:4326');\n\n  const cosLat1 = Math.cos(toRadians(lat1));\n  const sinLat1 = Math.sin(toRadians(lat1));\n  const cosLat2 = Math.cos(toRadians(lat2));\n  const sinLat2 = Math.sin(toRadians(lat2));\n  const cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  const sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  const d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      if (1 <= d) {\n        return [lon2, lat2];\n      }\n      const D = frac * Math.acos(d);\n      const cosD = Math.cos(D);\n      const sinD = Math.sin(D);\n      const y = sinDeltaLon * cosLat2;\n      const x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n      const theta = Math.atan2(y, x);\n      const lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n      const lon =\n        toRadians(lon1) +\n        Math.atan2(\n          Math.sin(theta) * sinD * cosLat1,\n          cosD - sinLat1 * Math.sin(lat)\n        );\n      return [toDegrees(lon), toDegrees(lat)];\n    },\n    getTransform(geoProjection, projection),\n    squaredTolerance\n  );\n}\n\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      return [lon, lat1 + (lat2 - lat1) * frac];\n    },\n    getTransform(epsg4326Projection, projection),\n    squaredTolerance\n  );\n}\n\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  const epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n      return [lon1 + (lon2 - lon1) * frac, lat];\n    },\n    getTransform(epsg4326Projection, projection),\n    squaredTolerance\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}