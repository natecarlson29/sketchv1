{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport { abstract } from '../util.js';\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nvar LayerRenderer = /** @class */function (_super) {\n  __extends(LayerRenderer, _super);\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  function LayerRenderer(layer) {\n    var _this = _super.call(this) || this;\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    _this.ready = true;\n    /** @private */\n    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    _this.layer_ = layer;\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    _this.declutterExecutorGroup = null;\n    return _this;\n  }\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n  LayerRenderer.prototype.getFeatures = function (pixel) {\n    return abstract();\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  LayerRenderer.prototype.getData = function (pixel) {\n    return null;\n  };\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  LayerRenderer.prototype.prepareFrame = function (frameState) {\n    return abstract();\n  };\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  LayerRenderer.prototype.renderFrame = function (frameState, target) {\n    return abstract();\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  };\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        var callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  };\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n    return undefined;\n  };\n  /**\n   * @abstract\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n   *    location, null will be returned.  If there is data, but pixel values cannot be\n   *    returned, and empty array will be returned.\n   */\n  LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n    return null;\n  };\n  /**\n   * @return {LayerType} Layer.\n   */\n  LayerRenderer.prototype.getLayer = function () {\n    return this.layer_;\n  };\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  LayerRenderer.prototype.handleFontsChanged = function () {};\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  LayerRenderer.prototype.handleImageChange_ = function (event) {\n    var image = /** @type {import(\"../Image.js\").default} */event.target;\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  LayerRenderer.prototype.loadImage = function (image) {\n    var imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  };\n  /**\n   * @protected\n   */\n  LayerRenderer.prototype.renderIfReadyAndVisible = function () {\n    var layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  };\n  /**\n   * Clean up.\n   */\n  LayerRenderer.prototype.disposeInternal = function () {\n    delete this.layer_;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return LayerRenderer;\n}(Observable);\nexport default LayerRenderer;","map":{"version":3,"names":["EventType","ImageState","Observable","abstract","LayerRenderer","_super","__extends","layer","_this","call","ready","boundHandleImageChange_","handleImageChange_","bind","layer_","declutterExecutorGroup","prototype","getFeatures","pixel","getData","prepareFrame","frameState","renderFrame","target","loadedTileCallback","tiles","zoom","tile","tileCoord","toString","undefined","createLoadedTileFinder","source","projection","tileRange","callback","forEachLoadedTile","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","getDataAtPixel","getLayer","handleFontsChanged","event","image","getState","LOADED","renderIfReadyAndVisible","loadImage","imageState","ERROR","addEventListener","CHANGE","IDLE","load","getVisible","getSourceState","changed","disposeInternal"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\renderer\\Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n   *    location, null will be returned.  If there is data, but pixel values cannot be\n   *    returned, and empty array will be returned.\n   */\n  getDataAtPixel(pixel, frameState, hitTolerance) {\n    return null;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}