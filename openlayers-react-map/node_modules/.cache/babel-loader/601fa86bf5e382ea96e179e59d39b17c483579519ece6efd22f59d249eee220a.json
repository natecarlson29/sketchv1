{"ast":null,"code":"import LineString from 'ol/geom/LineString';\nimport Overlay from 'ol/Overlay';\n\n// Format length in feet or miles\nexport function formatLength(line) {\n  const lengthMeters = line.getLength ? line.getLength() : 0;\n  const lengthFeet = lengthMeters * 3.28084;\n  return lengthFeet > 5280 ? (lengthFeet / 5280).toFixed(2) + ' mi' : lengthFeet.toFixed(2) + \"'\";\n}\n\n// Remove all overlays for a feature (Polygon or LineString)\nexport function clearPolygonOverlays(feature, mapRef) {\n  if (feature && feature._segmentOverlays) {\n    feature._segmentOverlays.forEach(overlay => {\n      if (mapRef && mapRef.current) mapRef.current.removeOverlay(overlay);\n    });\n    feature._segmentOverlays = [];\n  }\n}\n\n// Create overlays for each segment of a Polygon or LineString\nexport function createSegmentOverlays(feature, coords, mapRef) {\n  clearPolygonOverlays(feature, mapRef);\n  const DIM_OFFSET = 17;\n  feature._segmentOverlays = [];\n\n  // For Polygon, use first ring; for LineString, use coords directly\n  let points = coords;\n  if (feature.getGeometry().getType() === 'Polygon') {\n    points = coords[0];\n  }\n  for (let i = 1; i < points.length; i++) {\n    const c1 = points[i - 1];\n    const c2 = points[i];\n    const line = new LineString([c1, c2]);\n    const length = formatLength(line);\n\n    // Calculate perpendicular offset direction (in screen pixels)\n    const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\n    const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\n    const dx = pixel2[0] - pixel1[0];\n    const dy = pixel2[1] - pixel1[1];\n    const len = Math.sqrt(dx * dx + dy * dy);\n    const perp = len === 0 ? [0, 0] : [dy / len, -(dx / len)];\n\n    // Offset midpoint in screen pixels\n    const offsetMidPixel = [(pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET, (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET];\n    const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\n\n    // Place the tooltip at the offset position\n    const tooltip = document.createElement('div');\n    tooltip.className = 'segment-tooltip';\n    tooltip.innerHTML = length;\n\n    // Rotate the tooltip if the segment is more vertical than horizontal\n    const isVertical = Math.abs(dx) < Math.abs(dy) * 0.5;\n    if (isVertical) {\n      tooltip.style.transform = 'rotate(270deg)';\n    }\n    const overlay = new Overlay({\n      element: tooltip,\n      position: offsetMidCoord,\n      positioning: 'center-center',\n      stopEvent: false\n    });\n    mapRef.current.addOverlay(overlay);\n    feature._segmentOverlays.push(overlay);\n  }\n}\n\n// Remark segments for a Polygon\nexport function remarkPolygonSegments(feature, mapRef) {\n  if (!feature) return;\n  const poly = feature.getGeometry();\n  const coords = poly.getCoordinates()[0];\n  createSegmentOverlays(feature, [coords], mapRef);\n}\n\n// Remark segments for a LineString\nexport function remarkLineSegments(lineFeature, mapRef) {\n  if (!mapRef.current || !lineFeature) return;\n  createSegmentOverlays(lineFeature, lineFeature.getGeometry().getCoordinates(), mapRef);\n}\n\n// Place this helper function **outside** your App component, at the bottom of App.jsx (before export default App;):\n\nfunction pointToSegmentDistance(p, p1, p2) {\n  // p, p1, p2: [x, y]\n  const x = p[0],\n    y = p[1];\n  const x1 = p1[0],\n    y1 = p1[1];\n  const x2 = p2[0],\n    y2 = p2[1];\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n  const dot = A * C + B * D;\n  const len_sq = C * C + D * D;\n  let param = -1;\n  if (len_sq !== 0) param = dot / len_sq;\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}","map":{"version":3,"names":["LineString","Overlay","formatLength","line","lengthMeters","getLength","lengthFeet","toFixed","clearPolygonOverlays","feature","mapRef","_segmentOverlays","forEach","overlay","current","removeOverlay","createSegmentOverlays","coords","DIM_OFFSET","points","getGeometry","getType","i","length","c1","c2","pixel1","getPixelFromCoordinate","pixel2","dx","dy","len","Math","sqrt","perp","offsetMidPixel","offsetMidCoord","getCoordinateFromPixel","tooltip","document","createElement","className","innerHTML","isVertical","abs","style","transform","element","position","positioning","stopEvent","addOverlay","push","remarkPolygonSegments","poly","getCoordinates","remarkLineSegments","lineFeature","pointToSegmentDistance","p","p1","p2","x","y","x1","y1","x2","y2","A","B","C","D","dot","len_sq","param","xx","yy"],"sources":["C:/Users/ncarl/Desktop/sketch/openlayers-react-map/src/map-helpers/Measurements.js"],"sourcesContent":["import LineString from 'ol/geom/LineString';\r\nimport Overlay from 'ol/Overlay';\r\n\r\n// Format length in feet or miles\r\nexport function formatLength(line) {\r\n  const lengthMeters = line.getLength ? line.getLength() : 0;\r\n  const lengthFeet = lengthMeters * 3.28084;\r\n  return lengthFeet > 5280\r\n    ? (lengthFeet / 5280).toFixed(2) + ' mi'\r\n    : lengthFeet.toFixed(2) + \"'\";\r\n}\r\n\r\n// Remove all overlays for a feature (Polygon or LineString)\r\nexport function clearPolygonOverlays(feature, mapRef) {\r\n  if (feature && feature._segmentOverlays) {\r\n    feature._segmentOverlays.forEach(overlay => {\r\n      if (mapRef && mapRef.current) mapRef.current.removeOverlay(overlay);\r\n    });\r\n    feature._segmentOverlays = [];\r\n  }\r\n}\r\n\r\n// Create overlays for each segment of a Polygon or LineString\r\nexport function createSegmentOverlays(feature, coords, mapRef) {\r\n  clearPolygonOverlays(feature, mapRef);\r\n  const DIM_OFFSET = 17;\r\n  feature._segmentOverlays = [];\r\n\r\n  // For Polygon, use first ring; for LineString, use coords directly\r\n  let points = coords;\r\n  if (feature.getGeometry().getType() === 'Polygon') {\r\n    points = coords[0];\r\n  }\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    const c1 = points[i - 1];\r\n    const c2 = points[i];\r\n    const line = new LineString([c1, c2]);\r\n    const length = formatLength(line);\r\n\r\n    // Calculate perpendicular offset direction (in screen pixels)\r\n    const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\r\n    const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\r\n    const dx = pixel2[0] - pixel1[0];\r\n    const dy = pixel2[1] - pixel1[1];\r\n    const len = Math.sqrt(dx * dx + dy * dy);\r\n    const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\r\n\r\n    // Offset midpoint in screen pixels\r\n    const offsetMidPixel = [\r\n      (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\r\n      (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\r\n    ];\r\n    const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\r\n\r\n    // Place the tooltip at the offset position\r\n    const tooltip = document.createElement('div');\r\n    tooltip.className = 'segment-tooltip';\r\n    tooltip.innerHTML = length;\r\n\r\n    // Rotate the tooltip if the segment is more vertical than horizontal\r\n    const isVertical = Math.abs(dx) < Math.abs(dy) * 0.5;\r\n    if (isVertical) {\r\n      tooltip.style.transform = 'rotate(270deg)';\r\n    }\r\n\r\n    const overlay = new Overlay({\r\n      element: tooltip,\r\n      position: offsetMidCoord,\r\n      positioning: 'center-center',\r\n      stopEvent: false,\r\n    });\r\n    mapRef.current.addOverlay(overlay);\r\n    feature._segmentOverlays.push(overlay);\r\n  }\r\n}\r\n\r\n// Remark segments for a Polygon\r\nexport function remarkPolygonSegments(feature, mapRef) {\r\n  if (!feature) return;\r\n  const poly = feature.getGeometry();\r\n  const coords = poly.getCoordinates()[0];\r\n  createSegmentOverlays(feature, [coords], mapRef);\r\n}\r\n\r\n// Remark segments for a LineString\r\nexport function remarkLineSegments(lineFeature, mapRef) {\r\n  if (!mapRef.current || !lineFeature) return;\r\n  createSegmentOverlays(lineFeature, lineFeature.getGeometry().getCoordinates(), mapRef);\r\n}\r\n\r\n// Place this helper function **outside** your App component, at the bottom of App.jsx (before export default App;):\r\n\r\nfunction pointToSegmentDistance(p, p1, p2) {\r\n  // p, p1, p2: [x, y]\r\n  const x = p[0], y = p[1];\r\n  const x1 = p1[0], y1 = p1[1];\r\n  const x2 = p2[0], y2 = p2[1];\r\n  const A = x - x1;\r\n  const B = y - y1;\r\n  const C = x2 - x1;\r\n  const D = y2 - y1;\r\n\r\n  const dot = A * C + B * D;\r\n  const len_sq = C * C + D * D;\r\n  let param = -1;\r\n  if (len_sq !== 0) param = dot / len_sq;\r\n\r\n  let xx, yy;\r\n  if (param < 0) {\r\n    xx = x1;\r\n    yy = y1;\r\n  } else if (param > 1) {\r\n    xx = x2;\r\n    yy = y2;\r\n  } else {\r\n    xx = x1 + param * C;\r\n    yy = y1 + param * D;\r\n  }\r\n\r\n  const dx = x - xx;\r\n  const dy = y - yy;\r\n  return Math.sqrt(dx * dx + dy * dy);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}