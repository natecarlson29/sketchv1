{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { applyTransform, approximatelyEquals, containsCoordinate, containsExtent, equals, getCenter, getIntersection, getWidth, intersects, isEmpty, wrapX as wrapExtentX } from '../extent.js';\nimport { assign } from '../obj.js';\nimport { clamp } from '../math.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform } from '../proj.js';\nimport { getVectorContext } from '../render.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nvar DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)'\n});\n/**\n * @type {Array<number>}\n * @private\n */\nvar INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nvar Graticule = /** @class */function (_super) {\n  __extends(Graticule, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  function Graticule(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n      renderBuffer: 0\n    }, options);\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    _this = _super.call(this, baseOptions) || this;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    _this.projection_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLat_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLon_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLat_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minLon_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxX_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxY_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minX_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.minY_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.meridians_ = [];\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    _this.parallels_ = [];\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.fromLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    _this.toLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.projectionCenterLonLat_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.bottomRight_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.topRight_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.meridiansLabels_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    _this.parallelsLabels_ = null;\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'EW') : options.lonLabelFormatter;\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'NS') : options.latLabelFormatter;\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.lonLabelStyleBase_ = new Style({\n        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.lonLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(_this);\n      /**\n       * @type {Style}\n       * @private\n       */\n      _this.latLabelStyleBase_ = new Style({\n        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'right',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      _this.latLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(_this);\n      _this.meridiansLabels_ = [];\n      _this.parallelsLabels_ = [];\n      _this.addEventListener(EventType.POSTRENDER, _this.drawLabels_.bind(_this));\n    }\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS;\n    // use a source with a custom loader for lines & text\n    _this.setSource(new VectorSource({\n      loader: _this.loaderFunction.bind(_this),\n      strategy: _this.strategyFunction.bind(_this),\n      features: new Collection(),\n      overlaps: false,\n      useSpatialIndex: false,\n      wrapX: options.wrapX\n    }));\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    _this.featurePool_ = [];\n    /**\n     * @type {Style}\n     * @private\n     */\n    _this.lineStyle_ = new Style({\n      stroke: _this.strokeStyle_\n    });\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    _this.loadedExtent_ = null;\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    _this.renderedExtent_ = null;\n    /**\n     * @type {?number}\n     * @private\n     */\n    _this.renderedResolution_ = null;\n    _this.setRenderOrder(null);\n    return _this;\n  }\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  Graticule.prototype.strategyFunction = function (extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    var realWorldExtent = extent.slice();\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n    if (this.loadedExtent_) {\n      if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n    return [realWorldExtent];\n  };\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n  Graticule.prototype.loaderFunction = function (extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    var source = this.getSource();\n    // only consider the intersection between our own extent & the requested one\n    var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];\n    var renderExtent = getIntersection(layerExtent, extent);\n    if (this.renderedExtent_ && equals(this.renderedExtent_, renderExtent) && this.renderedResolution_ === resolution) {\n      return;\n    }\n    this.renderedExtent_ = renderExtent;\n    this.renderedResolution_ = resolution;\n    // bail out if nothing to render\n    if (isEmpty(renderExtent)) {\n      return;\n    }\n    // update projection info\n    var center = getCenter(renderExtent);\n    var squaredTolerance = resolution * resolution / 4;\n    var updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n    // first make sure we have enough features in the pool\n    var featureCount = this.meridians_.length + this.parallels_.length;\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n    var feature;\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n    var featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    var poolIndex = 0;\n    // add features for the lines & labels\n    var i, l;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {\n    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        var text = this.lonLabelFormatter_(lon);\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {\n    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        var text = this.latLabelFormatter_(lat);\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  };\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n  Graticule.prototype.drawLabels_ = function (event) {\n    var rotation = event.frameState.viewState.rotation;\n    var resolution = event.frameState.viewState.resolution;\n    var size = event.frameState.size;\n    var extent = event.frameState.extent;\n    var rotationCenter = getCenter(extent);\n    var rotationExtent = extent;\n    if (rotation) {\n      var unrotatedWidth = size[0] * resolution;\n      var unrotatedHeight = size[1] * resolution;\n      rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];\n    }\n    var startWorld = 0;\n    var endWorld = 0;\n    var labelsAtStart = this.latLabelPosition_ < 0.5;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = getWidth(projectionExtent);\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      var inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n    var vectorContext = getVectorContext(event);\n    for (var world = startWorld; world <= endWorld; ++world) {\n      var poolIndex = this.meridians_.length + this.parallels_.length;\n      var feature = void 0,\n        index = void 0,\n        l = void 0,\n        textPoint = void 0;\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          var lineString = this.meridians_[index];\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            var clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n      if (this.parallelsLabels_) {\n        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            var lineString = this.parallels_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              var clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {\n    var interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n    var wrapX = false;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = getWidth(projectionExtent);\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    }\n    // Constrain the center to fit into the extent available to the graticule\n    var validCenterP = [clamp(center[0], this.minX_, this.maxX_), clamp(center[1], this.minY_, this.maxY_)];\n    // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n    var centerLonLat = this.toLonLatTransform_(validCenterP);\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n    var centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    var centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    var maxLines = this.maxLines_;\n    var cnt, idx, lat, lon;\n    // Limit the extent to fit into the extent available to the graticule\n    var validExtentP = extent;\n    if (!wrapX) {\n      validExtentP = [clamp(extent[0], this.minX_, this.maxX_), clamp(extent[1], this.minY_, this.maxY_), clamp(extent[2], this.minX_, this.maxX_), clamp(extent[3], this.minY_, this.maxY_)];\n    }\n    // Transform the extent to get the lon lat ranges for the edges of the extent\n    var validExtent = applyTransform(validExtentP, this.toLonLatTransform_, undefined, 8);\n    var maxLat = validExtent[3];\n    var maxLon = validExtent[2];\n    var minLat = validExtent[1];\n    var minLon = validExtent[0];\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      }\n      // The transformed center may also extend the lon lat ranges used for rendering\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    }\n    // Create meridians\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n    cnt = 0;\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    cnt = 0;\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n    // Create parallels\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  };\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  Graticule.prototype.getInterval_ = function (resolution) {\n    var centerLon = this.projectionCenterLonLat_[0];\n    var centerLat = this.projectionCenterLonLat_[1];\n    var interval = -1;\n    var target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n    var p1 = [];\n    /** @type {Array<number>} **/\n    var p2 = [];\n    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      var delta = clamp(this.intervals_[i] / 2, 0, 90);\n      // Don't attempt to transform latitudes beyond the poles!\n      var clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = this.intervals_[i];\n    }\n    return interval;\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {\n    var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n    var lineString = this.meridians_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n  Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var bottom = 1;\n    var top = flatCoordinates.length - 1;\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n    var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    var clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n    var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);\n    var coordinate = [coordinate0, lat];\n    var point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n  Graticule.prototype.getMeridians = function () {\n    return this.meridians_;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {\n    var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n    var lineString = this.parallels_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n  Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var left = 0;\n    var right = flatCoordinates.length - 2;\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n    var clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    var clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n    var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);\n    var coordinate = [lon, coordinate1];\n    var point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n  Graticule.prototype.getParallels = function () {\n    return this.parallels_;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  Graticule.prototype.updateProjectionInfo_ = function (projection) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    var worldExtent = projection.getWorldExtent();\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n    // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n    var toLonLatTransform = getTransform(projection, epsg4326Projection);\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      var split_1 = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n      this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {\n        var dimension = opt_dimension || 2;\n        var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);\n        for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split_1) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n        return lonLatCoordinates;\n      };\n    }\n    // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    var worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3];\n    // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n    // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n    this.projection_ = projection;\n  };\n  return Graticule;\n}(VectorLayer);\nexport default Graticule;","map":{"version":3,"names":["Collection","EventType","Feature","Fill","GeometryLayout","LineString","Point","Stroke","Style","Text","VectorLayer","VectorSource","applyTransform","approximatelyEquals","containsCoordinate","containsExtent","equals","getCenter","getIntersection","getWidth","intersects","isEmpty","wrapX","wrapExtentX","assign","clamp","degreesToStringHDMS","equivalent","equivalentProjection","get","getProjection","getTransform","getVectorContext","meridian","parallel","DEFAULT_STROKE_STYLE","color","INTERVALS","Graticule","_super","__extends","opt_options","_this","options","baseOptions","updateWhileAnimating","updateWhileInteracting","renderBuffer","maxLines","strokeStyle","targetSize","showLabels","lonLabelFormatter","latLabelFormatter","lonLabelPosition","latLabelPosition","lonLabelStyle","latLabelStyle","intervals","call","projection_","maxLat_","Infinity","maxLon_","minLat_","minLon_","maxX_","maxY_","minX_","minY_","targetSize_","undefined","maxLines_","meridians_","parallels_","strokeStyle_","fromLonLatTransform_","toLonLatTransform_","projectionCenterLonLat_","bottomLeft_","bottomRight_","topLeft_","topRight_","meridiansLabels_","parallelsLabels_","lonLabelFormatter_","bind","latLabelFormatter_","lonLabelPosition_","latLabelPosition_","lonLabelStyleBase_","text","clone","font","textBaseline","fill","stroke","width","lonLabelStyle_","feature","label","getText","setText","latLabelStyleBase_","textAlign","latLabelStyle_","addEventListener","POSTRENDER","drawLabels_","intervals_","setSource","loader","loaderFunction","strategy","strategyFunction","features","overlaps","useSpatialIndex","featurePool_","lineStyle_","loadedExtent_","renderedExtent_","renderedResolution_","setRenderOrder","prototype","extent","resolution","realWorldExtent","slice","getSource","getWrapX","removeLoadedExtent","projection","source","layerExtent","getExtent","renderExtent","center","squaredTolerance","updateProjectionInfo","updateProjectionInfo_","createGraticule_","featureCount","length","push","featuresColl","getFeaturesCollection","clear","poolIndex","i","l","setGeometry","setStyle","addMeridian_","lon","minLat","maxLat","index","lineString","getMeridian_","geom","addParallel_","lat","minLon","maxLon","getParallel_","event","rotation","frameState","viewState","size","rotationCenter","rotationExtent","unrotatedWidth","unrotatedHeight","startWorld","endWorld","labelsAtStart","projectionExtent","worldWidth","canWrapX","Math","floor","ceil","inverted","abs","PI","vectorContext","world","textPoint","getMeridianPoint_","translate","rotate","set","drawFeature","getParallelPoint_","interval","getInterval_","validCenterP","centerLonLat","isNaN","centerLon","centerLat","cnt","idx","validExtentP","validExtent","max","min","target","pow","p1","p2","ii","delta","clampedLat","dist","flatCoordinates","XY","setFlatCoordinates","changed","getFlatCoordinates","bottom","top","clampedBottom","clampedTop","coordinate0","coordinate","point","setCoordinates","getMeridians","left","right","clampedLeft","clampedRight","coordinate1","getParallels","epsg4326Projection","worldExtent","getWorldExtent","toLonLatTransform","split_1","coordinates","opt_output","opt_dimension","dimension","lonLatCoordinates","worldExtentP"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\layer\\Graticule.js"],"sourcesContent":["/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {\n  applyTransform,\n  approximatelyEquals,\n  containsCoordinate,\n  containsExtent,\n  equals,\n  getCenter,\n  getIntersection,\n  getWidth,\n  intersects,\n  isEmpty,\n  wrapX as wrapExtentX,\n} from '../extent.js';\nimport {assign} from '../obj.js';\nimport {clamp} from '../math.js';\nimport {degreesToStringHDMS} from '../coordinate.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n} from '../proj.js';\nimport {getVectorContext} from '../render.js';\nimport {meridian, parallel} from '../geom/flat/geodesic.js';\n\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nconst DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)',\n});\n\n/**\n * @type {Array<number>}\n * @private\n */\nconst INTERVALS = [\n  90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001,\n];\n\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle] The\n * stroke style to use for drawing the graticule. If not provided, the following stroke will be used:\n * ```js\n * new Stroke({\n *   color: 'rgba(0, 0, 0, 0.2)' // a not fully opaque black\n * });\n * ```\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nclass Graticule extends VectorLayer {\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    const baseOptions = assign(\n      {\n        updateWhileAnimating: true,\n        updateWhileInteracting: true,\n        renderBuffer: 0,\n      },\n      options\n    );\n\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    super(baseOptions);\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.projection_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLat_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLon_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLat_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minLon_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxX_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxY_ = Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minX_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minY_ = -Infinity;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.targetSize_ =\n      options.targetSize !== undefined ? options.targetSize : 100;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.meridians_ = [];\n\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n    this.parallels_ = [];\n\n    /**\n     * @type {Stroke}\n     * @private\n     */\n    this.strokeStyle_ =\n      options.strokeStyle !== undefined\n        ? options.strokeStyle\n        : DEFAULT_STROKE_STYLE;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.fromLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n    this.toLonLatTransform_ = undefined;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.projectionCenterLonLat_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.bottomRight_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topLeft_ = null;\n\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.topRight_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.meridiansLabels_ = null;\n\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n    this.parallelsLabels_ = null;\n\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      this.lonLabelFormatter_ =\n        options.lonLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'EW')\n          : options.lonLabelFormatter;\n\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n      this.latLabelFormatter_ =\n        options.latLabelFormatter == undefined\n          ? degreesToStringHDMS.bind(this, 'NS')\n          : options.latLabelFormatter;\n\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n      this.lonLabelPosition_ =\n        options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n      this.latLabelPosition_ =\n        options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.lonLabelStyleBase_ = new Style({\n        text:\n          options.lonLabelStyle !== undefined\n            ? options.lonLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textBaseline: 'bottom',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.lonLabelStyle_ = function (feature) {\n        const label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(this);\n\n      /**\n       * @type {Style}\n       * @private\n       */\n      this.latLabelStyleBase_ = new Style({\n        text:\n          options.latLabelStyle !== undefined\n            ? options.latLabelStyle.clone()\n            : new Text({\n                font: '12px Calibri,sans-serif',\n                textAlign: 'right',\n                fill: new Fill({\n                  color: 'rgba(0,0,0,1)',\n                }),\n                stroke: new Stroke({\n                  color: 'rgba(255,255,255,1)',\n                  width: 3,\n                }),\n              }),\n      });\n\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n      this.latLabelStyle_ = function (feature) {\n        const label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(this);\n\n      this.meridiansLabels_ = [];\n      this.parallelsLabels_ = [];\n\n      this.addEventListener(EventType.POSTRENDER, this.drawLabels_.bind(this));\n    }\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.intervals_ =\n      options.intervals !== undefined ? options.intervals : INTERVALS;\n\n    // use a source with a custom loader for lines & text\n    this.setSource(\n      new VectorSource({\n        loader: this.loaderFunction.bind(this),\n        strategy: this.strategyFunction.bind(this),\n        features: new Collection(),\n        overlaps: false,\n        useSpatialIndex: false,\n        wrapX: options.wrapX,\n      })\n    );\n\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n    this.featurePool_ = [];\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.lineStyle_ = new Style({\n      stroke: this.strokeStyle_,\n    });\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.loadedExtent_ = null;\n\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.renderedResolution_ = null;\n\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n  strategyFunction(extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    let realWorldExtent = extent.slice();\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n    if (this.loadedExtent_) {\n      if (\n        approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)\n      ) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n    return [realWorldExtent];\n  }\n\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n  loaderFunction(extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    const source = this.getSource();\n\n    // only consider the intersection between our own extent & the requested one\n    const layerExtent = this.getExtent() || [\n      -Infinity,\n      -Infinity,\n      Infinity,\n      Infinity,\n    ];\n    const renderExtent = getIntersection(layerExtent, extent);\n\n    if (\n      this.renderedExtent_ &&\n      equals(this.renderedExtent_, renderExtent) &&\n      this.renderedResolution_ === resolution\n    ) {\n      return;\n    }\n    this.renderedExtent_ = renderExtent;\n    this.renderedResolution_ = resolution;\n\n    // bail out if nothing to render\n    if (isEmpty(renderExtent)) {\n      return;\n    }\n\n    // update projection info\n    const center = getCenter(renderExtent);\n    const squaredTolerance = (resolution * resolution) / 4;\n\n    const updateProjectionInfo =\n      !this.projection_ || !equivalentProjection(this.projection_, projection);\n\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n\n    // first make sure we have enough features in the pool\n    let featureCount = this.meridians_.length + this.parallels_.length;\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n\n    let feature;\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n\n    const featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    let poolIndex = 0;\n\n    // add features for the lines & labels\n    let i, l;\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, index) {\n    const lineString = this.getMeridian_(\n      lon,\n      minLat,\n      maxLat,\n      squaredTolerance,\n      index\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        const text = this.lonLabelFormatter_(lon);\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.meridians_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n  addParallel_(lat, minLon, maxLon, squaredTolerance, extent, index) {\n    const lineString = this.getParallel_(\n      lat,\n      minLon,\n      maxLon,\n      squaredTolerance,\n      index\n    );\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        const text = this.latLabelFormatter_(lat);\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text,\n          };\n        }\n      }\n      this.parallels_[index++] = lineString;\n    }\n    return index;\n  }\n\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n  drawLabels_(event) {\n    const rotation = event.frameState.viewState.rotation;\n    const resolution = event.frameState.viewState.resolution;\n    const size = event.frameState.size;\n    const extent = event.frameState.extent;\n    const rotationCenter = getCenter(extent);\n    let rotationExtent = extent;\n    if (rotation) {\n      const unrotatedWidth = size[0] * resolution;\n      const unrotatedHeight = size[1] * resolution;\n      rotationExtent = [\n        rotationCenter[0] - unrotatedWidth / 2,\n        rotationCenter[1] - unrotatedHeight / 2,\n        rotationCenter[0] + unrotatedWidth / 2,\n        rotationCenter[1] + unrotatedHeight / 2,\n      ];\n    }\n\n    let startWorld = 0;\n    let endWorld = 0;\n    let labelsAtStart = this.latLabelPosition_ < 0.5;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      const inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n    const vectorContext = getVectorContext(event);\n\n    for (let world = startWorld; world <= endWorld; ++world) {\n      let poolIndex = this.meridians_.length + this.parallels_.length;\n      let feature, index, l, textPoint;\n\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          const lineString = this.meridians_[index];\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            const clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n      if (this.parallelsLabels_) {\n        if (\n          (world === startWorld && labelsAtStart) ||\n          (world === endWorld && !labelsAtStart)\n        ) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            const lineString = this.parallels_[index];\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              const clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n  createGraticule_(extent, center, resolution, squaredTolerance) {\n    const interval = this.getInterval_(resolution);\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n      return;\n    }\n\n    let wrapX = false;\n    const projectionExtent = this.projection_.getExtent();\n    const worldWidth = getWidth(projectionExtent);\n    if (\n      this.getSource().getWrapX() &&\n      this.projection_.canWrapX() &&\n      !containsExtent(projectionExtent, extent)\n    ) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    }\n\n    // Constrain the center to fit into the extent available to the graticule\n\n    const validCenterP = [\n      clamp(center[0], this.minX_, this.maxX_),\n      clamp(center[1], this.minY_, this.maxY_),\n    ];\n\n    // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    const centerLonLat = this.toLonLatTransform_(validCenterP);\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n    let centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    let centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    const maxLines = this.maxLines_;\n    let cnt, idx, lat, lon;\n\n    // Limit the extent to fit into the extent available to the graticule\n\n    let validExtentP = extent;\n    if (!wrapX) {\n      validExtentP = [\n        clamp(extent[0], this.minX_, this.maxX_),\n        clamp(extent[1], this.minY_, this.maxY_),\n        clamp(extent[2], this.minX_, this.maxX_),\n        clamp(extent[3], this.minY_, this.maxY_),\n      ];\n    }\n\n    // Transform the extent to get the lon lat ranges for the edges of the extent\n\n    const validExtent = applyTransform(\n      validExtentP,\n      this.toLonLatTransform_,\n      undefined,\n      8\n    );\n\n    let maxLat = validExtent[3];\n    let maxLon = validExtent[2];\n    let minLat = validExtent[1];\n    let minLon = validExtent[0];\n\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      }\n\n      // The transformed center may also extend the lon lat ranges used for rendering\n\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    }\n\n    // Create meridians\n\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    }\n\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n\n    cnt = 0;\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(\n          lon,\n          minLat,\n          maxLat,\n          squaredTolerance,\n          extent,\n          idx\n        );\n      }\n    }\n\n    this.meridians_.length = idx;\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    }\n\n    // Create parallels\n\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n\n    cnt = 0;\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx\n      );\n    }\n\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n\n    cnt = 0;\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(\n        lat,\n        minLon,\n        maxLon,\n        squaredTolerance,\n        extent,\n        idx\n      );\n    }\n\n    this.parallels_.length = idx;\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n  getInterval_(resolution) {\n    const centerLon = this.projectionCenterLonLat_[0];\n    const centerLat = this.projectionCenterLonLat_[1];\n    let interval = -1;\n    const target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n    const p1 = [];\n    /** @type {Array<number>} **/\n    const p2 = [];\n    for (let i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      const delta = clamp(this.intervals_[i] / 2, 0, 90);\n      // Don't attempt to transform latitudes beyond the poles!\n      const clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      const dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n      if (dist <= target) {\n        break;\n      }\n      interval = this.intervals_[i];\n    }\n    return interval;\n  }\n\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getMeridian_(lon, minLat, maxLat, squaredTolerance, index) {\n    const flatCoordinates = meridian(\n      lon,\n      minLat,\n      maxLat,\n      this.projection_,\n      squaredTolerance\n    );\n    let lineString = this.meridians_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n  getMeridianPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let bottom = 1;\n    let top = flatCoordinates.length - 1;\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n    const clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    const clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    const lat = clamp(\n      extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_,\n      clampedBottom,\n      clampedTop\n    );\n    const coordinate0 =\n      flatCoordinates[bottom - 1] +\n      ((flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) *\n        (lat - flatCoordinates[bottom])) /\n        (flatCoordinates[top] - flatCoordinates[bottom]);\n    const coordinate = [coordinate0, lat];\n    const point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n  getMeridians() {\n    return this.meridians_;\n  }\n\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n  getParallel_(lat, minLon, maxLon, squaredTolerance, index) {\n    const flatCoordinates = parallel(\n      lat,\n      minLon,\n      maxLon,\n      this.projection_,\n      squaredTolerance\n    );\n    let lineString = this.parallels_[index];\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n    return lineString;\n  }\n\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n  getParallelPoint_(lineString, extent, index) {\n    const flatCoordinates = lineString.getFlatCoordinates();\n    let left = 0;\n    let right = flatCoordinates.length - 2;\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n    const clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    const clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    const lon = clamp(\n      extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_,\n      clampedLeft,\n      clampedRight\n    );\n    const coordinate1 =\n      flatCoordinates[left + 1] +\n      ((flatCoordinates[right + 1] - flatCoordinates[left + 1]) *\n        (lon - flatCoordinates[left])) /\n        (flatCoordinates[right] - flatCoordinates[left]);\n    const coordinate = [lon, coordinate1];\n    const point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  }\n\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n  getParallels() {\n    return this.parallels_;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateProjectionInfo_(projection) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const worldExtent = projection.getWorldExtent();\n\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0];\n\n    // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n\n    const toLonLatTransform = getTransform(projection, epsg4326Projection);\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      const split = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n      this.toLonLatTransform_ = function (\n        coordinates,\n        opt_output,\n        opt_dimension\n      ) {\n        const dimension = opt_dimension || 2;\n        const lonLatCoordinates = toLonLatTransform(\n          coordinates,\n          opt_output,\n          dimension\n        );\n        for (let i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n        return lonLatCoordinates;\n      };\n    }\n\n    // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    const worldExtentP = applyTransform(\n      [this.minLon_, this.minLat_, this.maxLon_, this.maxLat_],\n      this.fromLonLatTransform_,\n      undefined,\n      8\n    );\n\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3];\n\n    // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n\n    // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(\n      getCenter(projection.getExtent())\n    );\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] =\n        Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n          ? this.maxLat_\n          : this.minLat_;\n    }\n\n    this.projection_ = projection;\n  }\n}\n\nexport default Graticule;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}