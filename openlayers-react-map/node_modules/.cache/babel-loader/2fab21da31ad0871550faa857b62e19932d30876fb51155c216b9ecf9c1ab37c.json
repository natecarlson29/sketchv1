{"ast":null,"code":"import React,{useEffect,useRef,useState}from'react';import'./style.css';import'ol/ol.css';import Map from'ol/Map';import View from'ol/View';import TileLayer from'ol/layer/Tile';import OSM from'ol/source/OSM';import VectorLayer from'ol/layer/Vector';import VectorSource from'ol/source/Vector';import Feature from'ol/Feature';import Polygon from'ol/geom/Polygon';import LineString from'ol/geom/LineString';import Point from'ol/geom/Point';// import Select from 'ol/interaction/Select';\nimport{fromLonLat}from'ol/proj';import{ScaleLine,Rotate}from'ol/control';import Translate from'ol/interaction/Translate';import Snap from'ol/interaction/Snap';import{/*always,*/primaryAction}from'ol/events/condition';/* map actions */import History from'./map-helpers/History';import FlipHorizButton from'./map-actions/FlipHorizontal';import FlipVertButton from'./map-actions/FlipVertical';import RightClick from'./map-actions/RightClick';import Clone from'./map-actions/Clone';import QuickShape from'./map-actions/QuickShape';/* map stylings */import{polygonStyle,activePolygonStyle,selectedPolygonStyle,ghostMarkerStyle,highlightSegmentStyle,highlightVertexStyle,closingSegmentStyle}from'./ol-styles';/* svgs */import{DrawIcon,HandIcon}from'./svg';/* measurement helpers */import{clearPolygonOverlays,createSegmentOverlays,pointToSegmentDistance}from'./map-helpers/Measurements';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const OFFSET_REF_DEFAULT=1.524;const App=()=>{const[text,setText]=useState('');const textRef=useRef(text);const[mode,setMode]=useState('draw');const[selectedFeature,setSelectedFeature]=useState(null);const[contextMenu,setContextMenu]=useState({visible:false,x:0,y:0,type:null,feature:null,index:null});const[history,setHistory]=useState([]);const[redoStack,setRedoStack]=useState([]);const inputRef=useRef();const mapRef=useRef();const vectorSourceRef=useRef();const polygonFeatureRef=useRef();const drawingRef=useRef(false);const[drawing,setDrawing]=useState(false);const offsetRef=useRef(OFFSET_REF_DEFAULT);const ghostMarkerRef=useRef(null);const modeRef=useRef(mode);const selectInteractionRef=useRef(null);const vectorLayerRef=useRef();const[showHistory,setShowHistory]=useState(true);function addHistoryAction(action){setHistory(prev=>[...prev,action]);setRedoStack([]);//clear highlight layer\nif(action.type==='delete-vertex'||action.type==='delete-segment'){const highlightLayer=mapRef.current.getLayers().getArray().find(layer=>layer.get('name')==='highlight');if(highlightLayer){const highlightSource=highlightLayer.getSource();highlightSource.getFeatures().forEach(f=>{if(!f.get('isClosingSegment')){highlightSource.removeFeature(f);}});}}}//Polygon closing line shown with new style in highlight layer\nfunction updateClosingSegmentOverlay(){const highlightLayer=mapRef.current.getLayers().getArray().find(layer=>layer.get('name')==='highlight');if(!highlightLayer)return;const highlightSource=highlightLayer.getSource();// Remove previous closing segment overlays\nhighlightSource.getFeatures().forEach(f=>{if(f.get('isClosingSegment'))highlightSource.removeFeature(f);});if(drawingRef.current&&polygonFeatureRef.current&&polygonFeatureRef.current.getGeometry().getType()==='Polygon'){const coords=polygonFeatureRef.current.getGeometry().getCoordinates()[0];if(coords.length>1){const closingLine=new Feature(new LineString([coords[coords.length-2],coords[0]]));closingLine.setStyle(closingSegmentStyle);closingLine.set('isClosingSegment',true);highlightSource.addFeature(closingLine);}}}function coordsEqual(a,b){return a[0]===b[0]&&a[1]===b[1];}function getSnappedCoordinate(map,vectorSource,pointerPixel){let tolerance=arguments.length>3&&arguments[3]!==undefined?arguments[3]:25;let closestCoord=null;let minDist=Infinity;vectorSource.getFeatures().forEach(feature=>{const geom=feature.getGeometry();let coords=[];if(geom.getType()==='Polygon'){coords=geom.getCoordinates()[0];}else if(geom.getType()==='LineString'){coords=geom.getCoordinates();}coords.forEach(coord=>{const pixel=map.getPixelFromCoordinate(coord);const dist=Math.hypot(pointerPixel[0]-pixel[0],pointerPixel[1]-pixel[1]);if(dist<minDist&&dist<tolerance){minDist=dist;closestCoord=coord;}});});return closestCoord;}//select features / style\nuseEffect(()=>{var _vectorSourceRef$curr,_vectorSourceRef$curr2;const allFeatures=((_vectorSourceRef$curr=vectorSourceRef.current)===null||_vectorSourceRef$curr===void 0?void 0:(_vectorSourceRef$curr2=_vectorSourceRef$curr.getFeatures)===null||_vectorSourceRef$curr2===void 0?void 0:_vectorSourceRef$curr2.call(_vectorSourceRef$curr))||[];allFeatures.forEach(f=>{if(f===selectedFeature){f.setStyle(selectedPolygonStyle);}else{f.setStyle(polygonStyle);}});},[selectedFeature]);//Read textbox input to be mapped with addSegment\nuseEffect(()=>{textRef.current=text;const val=parseFloat(text);if(!isNaN(val)&&val>0){offsetRef.current=val*0.3048;}else{offsetRef.current=OFFSET_REF_DEFAULT;}},[text]);//Select vs Draw mode useEffect\nuseEffect(()=>{//sync modeRef with current mode\nmodeRef.current=mode;const map=mapRef.current;if(!map)return;if(mode!=='draw'&&ghostMarkerRef.current){vectorSourceRef.current.removeFeature(ghostMarkerRef.current);ghostMarkerRef.current=null;}if(selectInteractionRef.current){map.removeInteraction(selectInteractionRef.current);selectInteractionRef.current=null;}if(mode==='select'){let translate=new Translate({layers:[vectorLayerRef.current],condition:primaryAction});map.addInteraction(translate);selectInteractionRef.current=translate;// Listen for translateend to track moves\ntranslate.on('translateend',evt=>{evt.features.forEach(feature=>{// Save previous and new coordinates for undo/redo\nconst prevCoords=feature.get('_prevCoords')||feature.getGeometry().getCoordinates();const newCoords=feature.getGeometry().getCoordinates();addHistoryAction({type:'move-feature',featureId:feature.getId(),prevCoords,newCoords});// Update _prevCoords for future moves\nfeature.set('_prevCoords',newCoords);createSegmentOverlays(feature,mapRef);});});// Save the original coordinates before move starts\ntranslate.on('translatestart',evt=>{evt.features.forEach(feature=>{clearPolygonOverlays(feature,mapRef);feature.set('_prevCoords',feature.getGeometry().getCoordinates());setSelectedFeature(feature);});});}return()=>{if(selectInteractionRef.current){map.removeInteraction(selectInteractionRef.current);selectInteractionRef.current=null;}};},[mode]);/* MAIN USE EFFECT */useEffect(()=>{const vectorSource=new VectorSource();vectorSourceRef.current=vectorSource;const vectorLayer=new VectorLayer({source:vectorSource,style:polygonStyle});vectorLayerRef.current=vectorLayer;const map=new Map({target:'map',layers:[new TileLayer({source:new OSM()}),vectorLayer],view:new View({center:fromLonLat([-95.87,40.84]),zoom:24})});map.addControl(new ScaleLine({units:'imperial'}));map.addControl(new Rotate({autoHide:false,duration:500}));const snapInteraction=new Snap({source:vectorSourceRef.current});map.addInteraction(snapInteraction);const highlightSource=new VectorSource();const highlightLayer=new VectorLayer({name:'highlight',source:highlightSource,style:highlightSegmentStyle});map.addLayer(highlightLayer);mapRef.current=map;// Expose createSegmentOverlays for use in handlers\nmapRef.current.createSegmentOverlays=(feature,mapRef)=>createSegmentOverlays(feature,mapRef);map.on('pointermove',evt=>{//GHOST MARKER LOGIC\nif(modeRef.current==='draw'&&!drawingRef.current){const coord=evt.coordinate;const pixel=evt.pixel;const map=mapRef.current;const vectorSource=vectorSourceRef.current;// Try to snap to existing vertices\nconst snappedCoord=getSnappedCoordinate(map,vectorSource,pixel,25)||coord;if(ghostMarkerRef.current){vectorSourceRef.current.removeFeature(ghostMarkerRef.current);}const ghost=new Feature(new Point(snappedCoord));ghost.setStyle(ghostMarkerStyle);vectorSourceRef.current.addFeature(ghost);ghostMarkerRef.current=ghost;}else if(ghostMarkerRef.current){vectorSourceRef.current.removeFeature(ghostMarkerRef.current);ghostMarkerRef.current=null;}else/* if (modeRef.current === 'select')*/{highlightSource.getFeatures().forEach(f=>{if(!f.get('isClosingSegment')){highlightSource.removeFeature(f);}});let found=false;// Hover logic for highlightLayer lines\nmap.forEachFeatureAtPixel(evt.pixel,(feature,layer)=>{if(feature.getGeometry().getType()==='Polygon'||feature.getGeometry().getType()==='LineString'){const coords=feature.getGeometry().getType()==='Polygon'?feature.getGeometry().getCoordinates()[0]:feature.getGeometry().getCoordinates();// Check for vertex hover first\nfor(let i=0;i<coords.length;i++){const pixel=map.getPixelFromCoordinate(coords[i]);const dist=Math.sqrt(Math.pow(evt.pixel[0]-pixel[0],2)+Math.pow(evt.pixel[1]-pixel[1],2));if(dist<8){// 8 pixels tolerance for vertex\nconst vertexFeature=new Feature(new Point(coords[i]));vertexFeature.setStyle(highlightVertexStyle);highlightSource.addFeature(vertexFeature);found=true;return true;// Stop after first found\n}}// If no vertex found, check for segment hover\nfor(let i=0;i<coords.length-1;i++){const seg=[coords[i],coords[i+1]];const pixel1=map.getPixelFromCoordinate(seg[0]);const pixel2=map.getPixelFromCoordinate(seg[1]);const dist=pointToSegmentDistance(evt.pixel,pixel1,pixel2);if(dist<8){// 8 pixels tolerance for segment\nconst segFeature=new Feature(new LineString(seg));segFeature.setStyle(highlightSegmentStyle);highlightSource.addFeature(segFeature);found=true;return true;// Stop after first found\n}}}return found;});}});function editExistingPolygon(snappedCoord,vectorSource){// Find a LineString whose endpoint matches snappedCoord\nlet foundLine=null;let foundIndex=null;vectorSource.getFeatures().forEach(feature=>{if(feature.getGeometry().getType()==='LineString'){const coords=feature.getGeometry().getCoordinates();// Check both ends\nif(coordsEqual(coords[0],snappedCoord)){foundLine=feature;foundIndex=0;}else if(coordsEqual(coords[coords.length-1],snappedCoord)){foundLine=feature;foundIndex=coords.length-1;}}});if(foundLine){// Remove the LineString from the source\nclearPolygonOverlays(foundLine,mapRef);vectorSource.removeFeature(foundLine);let coords=foundLine.getGeometry().getCoordinates();// If the user clicked the end, reverse so snappedCoord is first\nif(foundIndex===coords.length-1){coords=coords.slice().reverse();}// Start a new polygon with these coords (not closed yet)\nreturn coords;}// No matching linestring found\nreturn null;}function drawClick(evt){const coord=evt.coordinate;if(!drawingRef.current){if(ghostMarkerRef.current){vectorSourceRef.current.removeFeature(ghostMarkerRef.current);ghostMarkerRef.current=null;}const pixel=mapRef.current.getPixelFromCoordinate(coord);//custom snapping\nconst snappedCoord=getSnappedCoordinate(mapRef.current,vectorSourceRef.current,pixel,25)||coord;const vectorSource=vectorSourceRef.current;let initialCoords=editExistingPolygon(snappedCoord,vectorSource);let poly,feature;if(initialCoords){// Remove all instances of snappedCoord from the array\nlet coords=initialCoords.filter(c=>!coordsEqual(c,snappedCoord));// Push snappedCoord to the end\ncoords.push(snappedCoord);// Ensure the polygon is closed visually\nif(coords.length>2&&(coords[0][0]!==coords[coords.length-1][0]||coords[0][1]!==coords[coords.length-1][1])){coords.push([...coords[0]]);}console.log({NEWPOLY:coords});// Create the polygon (now closed)\npoly=new Polygon([coords]);feature=new Feature(poly);feature.setId(Date.now().toString());createSegmentOverlays(feature,mapRef);addHistoryAction({type:'convert-linestring-to-polygon',featureId:feature.getId(),prevCoords:initialCoords,// original LineString coordinates\nnewCoords:coords,// new Polygon coordinates\ngeomType:'Polygon',prevGeomType:'LineString'});}else{// Normal: start polygon with just the clicked point\npoly=new Polygon([[snappedCoord,snappedCoord]]);feature=new Feature(poly);feature.setId(Date.now().toString());addHistoryAction({type:'add-point',featureId:feature.getId(),prevCoords:[],newCoords:[[coord,coord]]});}feature.setStyle(activePolygonStyle);vectorSource.addFeature(feature);polygonFeatureRef.current=feature;drawingRef.current=true;setDrawing(true);}}function selectClick(evt){// maybe\nconst features=map.getFeaturesAtPixel(evt.pixel).filter(f=>vectorSourceRef.current.getFeatures().includes(f));// const features = map.getFeaturesAtPixel(evt.pixel);\nconst allPolygons=vectorSourceRef.current.getFeatures();if(!features||features.length===0){// Deselect all: reset style for all polygons\nallPolygons.forEach(f=>f.setStyle(polygonStyle));setSelectedFeature(null);return;}let currentIdx=-1;// Cycle to the next feature\nconst nextIdx=(currentIdx+1)%features.length;const nextFeature=features[nextIdx];setSelectedFeature(nextFeature);}// --- MAP CLICK HANDLER ---\nmap.on('singleclick',evt=>{//DISABLED CLICK TO DRAW\nif(modeRef.current==='draw'&&ghostMarkerRef.current){console.log('draw clicked');drawClick(evt);}if(modeRef.current==='select'){selectClick(evt);}});function addSegment(direction){if(!drawingRef.current)return;const feature=polygonFeatureRef.current;const poly=feature.getGeometry();let coords=poly.getCoordinates()[0];const last=coords.length===1?coords[0]:coords[coords.length-2];let dx=0,dy=0;const OFFSET=offsetRef.current;switch(direction){case'ArrowUp':dy=OFFSET;break;case'ArrowDown':dy=-OFFSET;break;case'ArrowLeft':dx=-OFFSET;break;case'ArrowRight':dx=OFFSET;break;default:return;}// Rotate the direction vector by the negative of the map's rotation\nconst map=mapRef.current;const rotation=map?map.getView().getRotation():0;const cos=Math.cos(rotation);const sin=Math.sin(rotation);const rotatedDx=dx*cos-dy*sin;const rotatedDy=dx*sin+dy*cos;const newPt=[last[0]+rotatedDx,last[1]+rotatedDy];const prevCoords=[...coords];coords=[...coords.slice(0,-1),newPt,coords[coords.length-1]];console.log({AddSegmentCoords:coords});poly.setCoordinates([coords]);updateClosingSegmentOverlay();createSegmentOverlays(feature,mapRef);// Track action in history\naddHistoryAction({type:'add-point',featureId:feature.getId(),prevCoords,newCoords:coords});}function handleUndo(){let lastActionForRedo=null;setHistory(prev=>{if(prev.length===0)return prev;const lastAction=prev[prev.length-1];lastActionForRedo=lastAction;// Find the feature by ID\nlet feature=null;if(lastAction.featureId){feature=vectorSourceRef.current.getFeatures().find(f=>f.getId()===lastAction.featureId);if(!feature&&polygonFeatureRef.current)feature=polygonFeatureRef.current;}else if(polygonFeatureRef.current){feature=polygonFeatureRef.current;}if(!feature)return prev.slice(0,-1);const prevCoords=lastAction.prevCoords;if(lastAction.type==='delete-segment'){// Remove the current feature (could be a LineString or Polygon)\nlet featureToRemove=vectorSourceRef.current.getFeatures().find(f=>f.getId&&f.getId()===lastAction.featureId);if(featureToRemove){clearPolygonOverlays(featureToRemove,mapRef);vectorSourceRef.current.removeFeature(featureToRemove);}let restoredFeature;if(lastAction.geomType==='Polygon'){restoredFeature=new Feature(new Polygon([lastAction.prevCoords]));}else if(lastAction.geomType==='LineString'){restoredFeature=new Feature(new LineString(lastAction.prevCoords));}if(restoredFeature&&lastAction.featureId)restoredFeature.setId(lastAction.featureId);if(restoredFeature){vectorSourceRef.current.addFeature(restoredFeature);polygonFeatureRef.current=restoredFeature;if(lastAction.prevCoords&&lastAction.prevCoords.length>1){updateClosingSegmentOverlay();createSegmentOverlays(restoredFeature,mapRef);}}return prev.slice(0,-1);}if(lastAction.type==='flip-horizontal'||lastAction.type==='flip-vertical'){if(feature){feature.getGeometry().setCoordinates([lastAction.prevCoords]);if(lastAction.prevCoords.length>1){createSegmentOverlays(feature,mapRef);}}return prev.slice(0,-1);}if(lastAction.type==='move-feature'){if(feature&&lastAction.prevCoords){feature.getGeometry().setCoordinates(lastAction.prevCoords);createSegmentOverlays(feature,mapRef);}return prev.slice(0,-1);}if(lastAction.type==='draw-circle'){// Remove the circle feature\nlet featureToRemove=vectorSourceRef.current.getFeatures().find(f=>f.getId&&f.getId()===lastAction.featureId);if(featureToRemove){clearPolygonOverlays(featureToRemove,mapRef);vectorSourceRef.current.removeFeature(featureToRemove);}return prev.slice(0,-1);}// If undoing would result in no points or just one, remove the feature and reset drawing state\nif(!prevCoords||prevCoords.length<=1){clearPolygonOverlays(feature,mapRef);vectorSourceRef.current.removeFeature(feature);polygonFeatureRef.current=null;drawingRef.current=false;setDrawing(false);return prev.slice(0,-1);}if(lastAction.type==='convert-linestring-to-polygon'){// Remove the polygon feature\nlet featureToRemove=vectorSourceRef.current.getFeatures().find(f=>f.getId&&f.getId()===lastAction.featureId);if(featureToRemove){clearPolygonOverlays(featureToRemove,mapRef);vectorSourceRef.current.removeFeature(featureToRemove);}// Restore the original LineString\nconst restoredFeature=new Feature(new LineString(lastAction.prevCoords));if(lastAction.featureId)restoredFeature.setId(lastAction.featureId);vectorSourceRef.current.addFeature(restoredFeature);polygonFeatureRef.current=restoredFeature;createSegmentOverlays(restoredFeature,mapRef);return prev.slice(0,-1);}// Otherwise, restore previous geometry\nconst geomType=feature.getGeometry().getType();if(geomType==='Polygon'){feature.getGeometry().setCoordinates([prevCoords]);}else if(geomType==='LineString'){feature.getGeometry().setCoordinates(prevCoords);}if(prevCoords.length>1){updateClosingSegmentOverlay();createSegmentOverlays(feature,mapRef);}return prev.slice(0,-1);});// Only push to redoStack ONCE per undo, after setHistory runs\nif(lastActionForRedo){setRedoStack(redoPrev=>[...redoPrev,lastActionForRedo]);}}function handleRedo(){setRedoStack(prev=>{if(prev.length===0)return prev;const lastAction=prev[prev.length-1];// Find the feature by ID\nlet feature=null;if(lastAction.featureId){feature=vectorSourceRef.current.getFeatures().find(f=>f.getId()===lastAction.featureId);if(!feature&&polygonFeatureRef.current)feature=polygonFeatureRef.current;}else if(polygonFeatureRef.current){feature=polygonFeatureRef.current;}const newCoords=lastAction.newCoords;if(lastAction.type==='delete-segment'){// Remove the polygon feature\nif(feature){clearPolygonOverlays(feature,mapRef);vectorSourceRef.current.removeFeature(feature);}// Create a new LineString feature with the newCoords\nconst LineString=require('ol/geom/LineString').default;const lineFeature=new Feature(new LineString(newCoords));if(lastAction.featureId)lineFeature.setId(lastAction.featureId);vectorSourceRef.current.addFeature(lineFeature);if(mapRef.current&&mapRef.current.remarkLineSegments){mapRef.current.remarkLineSegments(lineFeature);}updateClosingSegmentOverlay();setHistory(histPrev=>[...histPrev,lastAction]);return prev.slice(0,-1);}if(lastAction.type==='add-point'||lastAction.type==='delete-vertex'){if(feature){feature.getGeometry().setCoordinates([newCoords]);if(newCoords.length>1){createSegmentOverlays(feature,mapRef);}}updateClosingSegmentOverlay();setHistory(histPrev=>[...histPrev,lastAction]);return prev.slice(0,-1);}if(lastAction.type==='flip-horizontal'||lastAction.type==='flip-vertical'){if(feature){feature.getGeometry().setCoordinates([lastAction.newCoords]);if(lastAction.newCoords.length>1){createSegmentOverlays(feature,mapRef);}}setHistory(histPrev=>[...histPrev,lastAction]);return prev.slice(0,-1);}if(lastAction.type==='move-feature'){if(feature&&lastAction.newCoords){feature.getGeometry().setCoordinates(lastAction.newCoords);createSegmentOverlays(feature,mapRef);}setHistory(histPrev=>[...histPrev,lastAction]);return prev.slice(0,-1);}if(lastAction.type==='convert-linestring-to-polygon'){// Remove the LineString feature\nlet featureToRemove=vectorSourceRef.current.getFeatures().find(f=>f.getId&&f.getId()===lastAction.featureId);if(featureToRemove){clearPolygonOverlays(featureToRemove,mapRef);vectorSourceRef.current.removeFeature(featureToRemove);}// Restore the Polygon\nconst restoredFeature=new Feature(new Polygon([lastAction.newCoords]));if(lastAction.featureId)restoredFeature.setId(lastAction.featureId);restoredFeature.setStyle(activePolygonStyle);vectorSourceRef.current.addFeature(restoredFeature);polygonFeatureRef.current=restoredFeature;createSegmentOverlays(restoredFeature,mapRef);updateClosingSegmentOverlay();setHistory(histPrev=>[...histPrev,lastAction]);return prev.slice(0,-1);}if(lastAction.type==='draw-circle'){// Re-add the circle feature\nconst restoredFeature=new Feature(new Polygon(lastAction.coords));if(lastAction.featureId)restoredFeature.setId(lastAction.featureId);vectorSourceRef.current.addFeature(restoredFeature);setHistory(histPrev=>[...histPrev,lastAction]);return prev.slice(0,-1);}// Add more redo logic for other action types as needed...\nreturn prev;});}function rotateMapToHighlightedSegment(map,highlightSource){const features=highlightSource.getFeatures();const segFeature=features.find(f=>f.getGeometry().getType()==='LineString');if(!segFeature)return;const coords=segFeature.getGeometry().getCoordinates();if(coords.length<2)return;const[start,end]=coords;const view=map.getView();const currentRotation=view.getRotation();const startPixel=map.getPixelFromCoordinate(start);const endPixel=map.getPixelFromCoordinate(end);// Undo current rotation to get true screen-space angle\nconst cos=Math.cos(-currentRotation);const sin=Math.sin(-currentRotation);const dx=endPixel[0]-startPixel[0];const dy=endPixel[1]-startPixel[1];const unrotatedDx=dx*cos-dy*sin;const unrotatedDy=dx*sin+dy*cos;const angle=Math.atan2(unrotatedDy,unrotatedDx);const rotation=Math.PI/2-angle;// Center on the midpoint of the segment\nconst center=[(start[0]+end[0])/2,(start[1]+end[1])/2];view.animate({center,rotation,duration:600});}function handleKeyDown(e){if(e.key==='ArrowUp'||e.key==='ArrowDown'||e.key==='ArrowLeft'||e.key==='ArrowRight'){if(modeRef.current==='draw'){e.preventDefault();addSegment(e.key);}}// 'Enter' to calculate next line from the textbox input\nif(e.key==='Enter'&&drawingRef.current&&modeRef.current==='draw'){const feature=polygonFeatureRef.current;const poly=feature.getGeometry();let coords=poly.getCoordinates()[0];const last=coords.length===1?coords[0]:coords[coords.length-2];const input=textRef.current.trim().toUpperCase();let dx=0,dy=0;// 1. Handle direction notation (e.g. R10+U5)\nconst dirPattern=/^([RLUD]\\d+(\\+\\s*[RLUD]\\d+)*)$/;if(dirPattern.test(input)){// Split by '+'\nconst parts=input.split('+').map(s=>s.trim());for(const part of parts){const dir=part[0];const val=parseFloat(part.slice(1));if(isNaN(val))continue;const meters=val*0.3048;switch(dir){case'R':dx+=meters;break;case'L':dx-=meters;break;case'U':dy+=meters;break;case'D':dy-=meters;break;default:break;}}// Rotate the direction vector by the map's rotation\nconst map=mapRef.current;const rotation=map?map.getView().getRotation():0;const cos=Math.cos(rotation);const sin=Math.sin(rotation);const rotatedDx=dx*cos-dy*sin;const rotatedDy=dx*sin+dy*cos;const newPt=[last[0]+rotatedDx,last[1]+rotatedDy];const prevCoords=[...coords];coords=[...coords.slice(0,-1),newPt,coords[coords.length-1]];poly.setCoordinates([coords]);updateClosingSegmentOverlay();createSegmentOverlays(feature,mapRef);addHistoryAction({type:'add-point',featureId:feature.getId(),prevCoords,newCoords:coords});setText('');return;}// 2. Handle length/angle notation (e.g. 10/180)\nlet distance=0;let angleDeg=0;if(input.includes('/')){const[distStr,angleStr]=input.split('/');distance=parseFloat(distStr);angleDeg=parseFloat(angleStr);}else{distance=parseFloat(input);angleDeg=0;}if(isNaN(distance))return;// Invalid input\ndistance=distance*0.3048;const map=mapRef.current;const rotation=map?map.getView().getRotation():0;const angleRad=angleDeg*Math.PI/180+rotation;const dx2=distance*Math.cos(angleRad);const dy2=distance*Math.sin(angleRad);const newPt=[last[0]+dx2,last[1]+dy2];const prevCoords=[...coords];coords=[...coords.slice(0,-1),newPt,coords[coords.length-1]];poly.setCoordinates([coords]);createSegmentOverlays(feature,mapRef);addHistoryAction({type:'add-point',featureId:feature.getId(),prevCoords,newCoords:coords});setText('');}// 'a' to finish polygon\nif((e.key==='a'||e.key==='A')&&drawingRef.current&&modeRef.current==='draw'){const feature=polygonFeatureRef.current;const poly=feature.getGeometry();let coords=poly.getCoordinates()[0];if(coords.length>2){coords[coords.length-1]=coords[0];poly.setCoordinates([coords]);feature.setStyle(polygonStyle);createSegmentOverlays(feature,mapRef);drawingRef.current=false;setDrawing(false);setMode('');}const highlightLayer=mapRef.current.getLayers().getArray().find(layer=>layer.get('name')==='highlight');if(highlightLayer){const highlightSource=highlightLayer.getSource();highlightSource.getFeatures().forEach(f=>{if(f.get('isClosingSegment'))highlightSource.removeFeature(f);});}}// ctrl + z\nif((e.ctrlKey||e.metaKey)&&(e.key==='z'||e.key==='Z')){e.preventDefault();handleUndo();}// ctrl + y\nif((e.ctrlKey||e.metaKey)&&(e.key==='y'||e.key==='Y')){e.preventDefault();handleRedo();}//ctrl + r\nif((e.ctrlKey||e.metaKey)&&(e.key==='r'||e.key==='R')){e.preventDefault();const map=mapRef.current;const highlightLayer=map.getLayers().getArray().find(layer=>layer.get('name')==='highlight');if(map&&highlightLayer){rotateMapToHighlightedSegment(map,highlightLayer.getSource());}}}document.addEventListener('keydown',handleKeyDown);// Clean up on unmount\nreturn()=>{vectorSource.getFeatures().forEach(f=>clearPolygonOverlays(f,mapRef));map.setTarget(null);document.removeEventListener('keydown',handleKeyDown);if(selectInteractionRef.current){map.removeInteraction(selectInteractionRef.current);selectInteractionRef.current=null;}};},[]);return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"div\",{id:\"dimension-input-container\",children:/*#__PURE__*/_jsx(\"input\",{id:\"dimension-input\",ref:inputRef,type:\"text\",value:text,onChange:e=>setText(e.target.value),placeholder:\"Dimension (ft.)\",autoFocus:true,autoComplete:\"off\"})}),/*#__PURE__*/_jsxs(\"div\",{id:\"map-menu-vert\",children:[/*#__PURE__*/_jsx(\"button\",{title:\"Draw\",className:\"map-button\".concat(mode==='draw'?' active':''),onClick:()=>setMode('draw'),disabled:mode==='draw'&&drawing,children:/*#__PURE__*/_jsx(DrawIcon,{})}),/*#__PURE__*/_jsx(\"button\",{title:\"Select / Move\",className:\"map-button\".concat(mode==='select'?' active':''),onClick:()=>setMode('select'),disabled:mode==='draw'&&drawing,children:/*#__PURE__*/_jsx(HandIcon,{})}),/*#__PURE__*/_jsx(QuickShape,{mapRef:mapRef,vectorSourceRef:vectorSourceRef,setDrawing:setDrawing,setMode:setMode,addHistoryAction:addHistoryAction,mode:mode})]}),/*#__PURE__*/_jsxs(\"div\",{id:\"map-menu-horiz\",children:[/*#__PURE__*/_jsx(FlipHorizButton,{selectedFeature:selectedFeature,mapRef:mapRef,addHistoryAction:addHistoryAction}),/*#__PURE__*/_jsx(FlipVertButton,{selectedFeature:selectedFeature,mapRef:mapRef,addHistoryAction:addHistoryAction}),/*#__PURE__*/_jsx(Clone,{selectedFeature:selectedFeature,vectorSourceRef:vectorSourceRef,setSelectedFeature:setSelectedFeature,addHistoryAction:addHistoryAction,mapRef:mapRef}),/*#__PURE__*/_jsx(\"div\",{id:\"history-toggle\",className:\"map-button\".concat(showHistory?' active':''),onClick:()=>setShowHistory(v=>!v),children:\"History\"})]}),/*#__PURE__*/_jsx(\"div\",{id:\"map\"}),/*#__PURE__*/_jsx(RightClick,{mapRef:mapRef,vectorSourceRef:vectorSourceRef,contextMenu:contextMenu,setContextMenu:setContextMenu,clearPolygonOverlays:feature=>clearPolygonOverlays(feature,mapRef),addHistoryAction:addHistoryAction,drawing:drawing}),showHistory&&/*#__PURE__*/_jsx(History,{history:history,redoStack:redoStack})]});};export default App;","map":{"version":3,"names":["React","useEffect","useRef","useState","Map","View","TileLayer","OSM","VectorLayer","VectorSource","Feature","Polygon","LineString","Point","fromLonLat","ScaleLine","Rotate","Translate","Snap","primaryAction","History","FlipHorizButton","FlipVertButton","RightClick","Clone","QuickShape","polygonStyle","activePolygonStyle","selectedPolygonStyle","ghostMarkerStyle","highlightSegmentStyle","highlightVertexStyle","closingSegmentStyle","DrawIcon","HandIcon","clearPolygonOverlays","createSegmentOverlays","pointToSegmentDistance","jsx","_jsx","jsxs","_jsxs","OFFSET_REF_DEFAULT","App","text","setText","textRef","mode","setMode","selectedFeature","setSelectedFeature","contextMenu","setContextMenu","visible","x","y","type","feature","index","history","setHistory","redoStack","setRedoStack","inputRef","mapRef","vectorSourceRef","polygonFeatureRef","drawingRef","drawing","setDrawing","offsetRef","ghostMarkerRef","modeRef","selectInteractionRef","vectorLayerRef","showHistory","setShowHistory","addHistoryAction","action","prev","highlightLayer","current","getLayers","getArray","find","layer","get","highlightSource","getSource","getFeatures","forEach","f","removeFeature","updateClosingSegmentOverlay","getGeometry","getType","coords","getCoordinates","length","closingLine","setStyle","set","addFeature","coordsEqual","a","b","getSnappedCoordinate","map","vectorSource","pointerPixel","tolerance","arguments","undefined","closestCoord","minDist","Infinity","geom","coord","pixel","getPixelFromCoordinate","dist","Math","hypot","_vectorSourceRef$curr","_vectorSourceRef$curr2","allFeatures","call","val","parseFloat","isNaN","removeInteraction","translate","layers","condition","addInteraction","on","evt","features","prevCoords","newCoords","featureId","getId","vectorLayer","source","style","target","view","center","zoom","addControl","units","autoHide","duration","snapInteraction","name","addLayer","coordinate","snappedCoord","ghost","found","forEachFeatureAtPixel","i","sqrt","pow","vertexFeature","seg","pixel1","pixel2","segFeature","editExistingPolygon","foundLine","foundIndex","slice","reverse","drawClick","initialCoords","poly","filter","c","push","console","log","NEWPOLY","setId","Date","now","toString","geomType","prevGeomType","selectClick","getFeaturesAtPixel","includes","allPolygons","currentIdx","nextIdx","nextFeature","addSegment","direction","last","dx","dy","OFFSET","rotation","getView","getRotation","cos","sin","rotatedDx","rotatedDy","newPt","AddSegmentCoords","setCoordinates","handleUndo","lastActionForRedo","lastAction","featureToRemove","restoredFeature","redoPrev","handleRedo","require","default","lineFeature","remarkLineSegments","histPrev","rotateMapToHighlightedSegment","start","end","currentRotation","startPixel","endPixel","unrotatedDx","unrotatedDy","angle","atan2","PI","animate","handleKeyDown","e","key","preventDefault","input","trim","toUpperCase","dirPattern","test","parts","split","s","part","dir","meters","distance","angleDeg","distStr","angleStr","angleRad","dx2","dy2","ctrlKey","metaKey","document","addEventListener","setTarget","removeEventListener","children","id","ref","value","onChange","placeholder","autoFocus","autoComplete","title","className","concat","onClick","disabled","v"],"sources":["C:/Users/ncarl/Desktop/sketch/openlayers-react-map/src/App.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport './style.css';\nimport 'ol/ol.css';\nimport Map from 'ol/Map';\nimport View from 'ol/View';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport Feature from 'ol/Feature';\nimport Polygon from 'ol/geom/Polygon';\nimport LineString from 'ol/geom/LineString';\nimport Point from 'ol/geom/Point';\n// import Select from 'ol/interaction/Select';\nimport { fromLonLat } from 'ol/proj';\nimport { ScaleLine, Rotate } from 'ol/control';\nimport Translate from 'ol/interaction/Translate';\nimport Snap from 'ol/interaction/Snap';\nimport { /*always,*/  primaryAction } from 'ol/events/condition';\n\n/* map actions */\nimport History from './map-helpers/History';\nimport FlipHorizButton from './map-actions/FlipHorizontal';\nimport FlipVertButton from './map-actions/FlipVertical';\nimport RightClick from './map-actions/RightClick';\nimport Clone from './map-actions/Clone';\nimport QuickShape from './map-actions/QuickShape';\n\n/* map stylings */\nimport {\n  polygonStyle,\n  activePolygonStyle,\n  selectedPolygonStyle,\n  ghostMarkerStyle,\n  highlightSegmentStyle,\n  highlightVertexStyle,\n  closingSegmentStyle\n} from './ol-styles';\n\n/* svgs */\nimport {\n  DrawIcon,\n  HandIcon\n} from './svg';\n\n/* measurement helpers */\nimport {\n  clearPolygonOverlays,\n  createSegmentOverlays,\n  pointToSegmentDistance\n} from './map-helpers/Measurements';\n\nconst OFFSET_REF_DEFAULT = 1.524;\n\nconst App = () => {\n  const [text, setText] = useState('');\n  const textRef = useRef(text);\n  const [mode, setMode] = useState('draw');\n  const [selectedFeature, setSelectedFeature] = useState(null);\n  const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, type: null, feature: null, index: null });\n  const [history, setHistory] = useState([]);\n  const [redoStack, setRedoStack] = useState([]);\n  const inputRef = useRef();\n  const mapRef = useRef();\n  const vectorSourceRef = useRef();\n  const polygonFeatureRef = useRef();\n  const drawingRef = useRef(false);\n  const [drawing, setDrawing] = useState(false);\n  const offsetRef = useRef(OFFSET_REF_DEFAULT);\n  const ghostMarkerRef = useRef(null);\n  const modeRef = useRef(mode);\n  const selectInteractionRef = useRef(null);\n  const vectorLayerRef = useRef();\n  const [showHistory, setShowHistory] = useState(true);\n\n  function addHistoryAction(action) {\n    setHistory(prev => [...prev, action]);\n    setRedoStack([]);\n\n    //clear highlight layer\n    if (action.type === 'delete-vertex' || action.type === 'delete-segment') {\n      const highlightLayer = mapRef.current.getLayers().getArray().find(layer => layer.get('name') === 'highlight');\n      if (highlightLayer) {\n        const highlightSource = highlightLayer.getSource();\n        highlightSource.getFeatures().forEach(f => {\n          if (!f.get('isClosingSegment')) {\n            highlightSource.removeFeature(f);\n          }\n        });\n      }\n    }\n  }\n\n  //Polygon closing line shown with new style in highlight layer\n  function updateClosingSegmentOverlay() {\n    const highlightLayer = mapRef.current.getLayers().getArray().find(layer => layer.get('name') === 'highlight');\n    if (!highlightLayer) return;\n    const highlightSource = highlightLayer.getSource();\n    // Remove previous closing segment overlays\n    highlightSource.getFeatures().forEach(f => {\n      if (f.get('isClosingSegment')) highlightSource.removeFeature(f);\n    });\n\n    if (\n      drawingRef.current &&\n      polygonFeatureRef.current &&\n      polygonFeatureRef.current.getGeometry().getType() === 'Polygon'\n    ) {\n      const coords = polygonFeatureRef.current.getGeometry().getCoordinates()[0];\n\n      if (coords.length > 1) {\n        const closingLine = new Feature(new LineString([coords[coords.length - 2], coords[0]]));\n        closingLine.setStyle(closingSegmentStyle);\n        closingLine.set('isClosingSegment', true);\n        highlightSource.addFeature(closingLine);\n      }\n    }\n  }\n\n  function coordsEqual(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n  }\n\n  function getSnappedCoordinate(map, vectorSource, pointerPixel, tolerance = 25) {\n    let closestCoord = null;\n    let minDist = Infinity;\n\n    vectorSource.getFeatures().forEach(feature => {\n      const geom = feature.getGeometry();\n      let coords = [];\n      if (geom.getType() === 'Polygon') {\n        coords = geom.getCoordinates()[0];\n      } else if (geom.getType() === 'LineString') {\n        coords = geom.getCoordinates();\n      }\n      coords.forEach(coord => {\n        const pixel = map.getPixelFromCoordinate(coord);\n        const dist = Math.hypot(pointerPixel[0] - pixel[0], pointerPixel[1] - pixel[1]);\n        if (dist < minDist && dist < tolerance) {\n          minDist = dist;\n          closestCoord = coord;\n        }\n      });\n    });\n\n    return closestCoord;\n  }\n\n  //select features / style\n  useEffect(() => {\n    const allFeatures = vectorSourceRef.current?.getFeatures?.() || [];\n    allFeatures.forEach(f => {\n      if (f === selectedFeature) {\n        f.setStyle(selectedPolygonStyle);\n      } else {\n        f.setStyle(polygonStyle);\n      }\n    });\n  }, [selectedFeature]);\n\n  //Read textbox input to be mapped with addSegment\n  useEffect(() => {\n    textRef.current = text;\n\n    const val = parseFloat(text);\n    if (!isNaN(val) && val > 0) {\n      offsetRef.current = val * 0.3048;\n    } else {\n      offsetRef.current = OFFSET_REF_DEFAULT;\n    }\n  }, [text]);\n\n  //Select vs Draw mode useEffect\n  useEffect(() => {\n    //sync modeRef with current mode\n    modeRef.current = mode;\n\n    const map = mapRef.current;\n    if (!map) return;\n\n    if (mode !== 'draw' && ghostMarkerRef.current) {\n      vectorSourceRef.current.removeFeature(ghostMarkerRef.current);\n      ghostMarkerRef.current = null;\n    }\n\n    if (selectInteractionRef.current) {\n      map.removeInteraction(selectInteractionRef.current);\n      selectInteractionRef.current = null;\n    }\n\n    if (mode === 'select') {\n      let translate = new Translate({ layers: [vectorLayerRef.current], condition: primaryAction });\n      map.addInteraction(translate);\n      selectInteractionRef.current = translate;\n\n      // Listen for translateend to track moves\n      translate.on('translateend', (evt) => {\n        evt.features.forEach(feature => {\n          // Save previous and new coordinates for undo/redo\n          const prevCoords = feature.get('_prevCoords') || feature.getGeometry().getCoordinates();\n          const newCoords = feature.getGeometry().getCoordinates();\n          addHistoryAction({\n            type: 'move-feature',\n            featureId: feature.getId(),\n            prevCoords,\n            newCoords,\n          });\n          // Update _prevCoords for future moves\n          feature.set('_prevCoords', newCoords);\n          createSegmentOverlays(feature, mapRef);\n\n        });\n      });\n\n      // Save the original coordinates before move starts\n      translate.on('translatestart', (evt) => {\n        evt.features.forEach(feature => {\n          clearPolygonOverlays(feature, mapRef);\n          feature.set('_prevCoords', feature.getGeometry().getCoordinates());\n          setSelectedFeature(feature);\n        });\n      });\n    }\n\n    return () => {\n      if (selectInteractionRef.current) {\n        map.removeInteraction(selectInteractionRef.current);\n        selectInteractionRef.current = null;\n      }\n    };\n  }, [mode]);\n\n  /* MAIN USE EFFECT */\n\n  useEffect(() => {\n    const vectorSource = new VectorSource();\n    vectorSourceRef.current = vectorSource;\n\n    const vectorLayer = new VectorLayer({\n      source: vectorSource,\n      style: polygonStyle,\n    });\n    vectorLayerRef.current = vectorLayer;\n\n    const map = new Map({\n      target: 'map',\n      layers: [\n        new TileLayer({ source: new OSM() }),\n        vectorLayer\n      ],\n      view: new View({\n        center: fromLonLat([-95.87, 40.84]),\n        zoom: 24,\n      }),\n    });\n\n    map.addControl(new ScaleLine({ units: 'imperial' }));\n    map.addControl(new Rotate({ autoHide: false, duration: 500 }));\n\n    const snapInteraction = new Snap({ source: vectorSourceRef.current });\n    map.addInteraction(snapInteraction)\n\n    const highlightSource = new VectorSource();\n    const highlightLayer = new VectorLayer({\n      name: 'highlight',\n      source: highlightSource,\n      style: highlightSegmentStyle,\n    });\n    map.addLayer(highlightLayer);\n\n    mapRef.current = map;\n\n    // Expose createSegmentOverlays for use in handlers\n    mapRef.current.createSegmentOverlays = (feature, mapRef) => createSegmentOverlays(feature, mapRef);\n\n    map.on('pointermove', evt => {\n      //GHOST MARKER LOGIC\n      if (modeRef.current === 'draw' && !drawingRef.current) {\n        const coord = evt.coordinate;\n        const pixel = evt.pixel;\n        const map = mapRef.current;\n        const vectorSource = vectorSourceRef.current;\n\n        // Try to snap to existing vertices\n        const snappedCoord = getSnappedCoordinate(map, vectorSource, pixel, 25) || coord;\n\n        if (ghostMarkerRef.current) {\n          vectorSourceRef.current.removeFeature(ghostMarkerRef.current);\n        }\n        const ghost = new Feature(new Point(snappedCoord));\n        ghost.setStyle(ghostMarkerStyle);\n        vectorSourceRef.current.addFeature(ghost);\n        ghostMarkerRef.current = ghost;\n      } else if (ghostMarkerRef.current) {\n        vectorSourceRef.current.removeFeature(ghostMarkerRef.current);\n        ghostMarkerRef.current = null;\n      } else/* if (modeRef.current === 'select')*/ {\n        highlightSource.getFeatures().forEach(f => {\n          if (!f.get('isClosingSegment')) {\n            highlightSource.removeFeature(f);\n          }\n        });\n\n        let found = false;\n        // Hover logic for highlightLayer lines\n        map.forEachFeatureAtPixel(evt.pixel, (feature, layer) => {\n          if (feature.getGeometry().getType() === 'Polygon' || feature.getGeometry().getType() === 'LineString') {\n            const coords = feature.getGeometry().getType() === 'Polygon'\n              ? feature.getGeometry().getCoordinates()[0]\n              : feature.getGeometry().getCoordinates();\n\n            // Check for vertex hover first\n            for (let i = 0; i < coords.length; i++) {\n              const pixel = map.getPixelFromCoordinate(coords[i]);\n              const dist = Math.sqrt(\n                Math.pow(evt.pixel[0] - pixel[0], 2) + Math.pow(evt.pixel[1] - pixel[1], 2)\n              );\n              if (dist < 8) { // 8 pixels tolerance for vertex\n                const vertexFeature = new Feature(new Point(coords[i]));\n                vertexFeature.setStyle(highlightVertexStyle);\n                highlightSource.addFeature(vertexFeature);\n                found = true;\n                return true; // Stop after first found\n              }\n            }\n\n            // If no vertex found, check for segment hover\n            for (let i = 0; i < coords.length - 1; i++) {\n              const seg = [coords[i], coords[i + 1]];\n              const pixel1 = map.getPixelFromCoordinate(seg[0]);\n              const pixel2 = map.getPixelFromCoordinate(seg[1]);\n              const dist = pointToSegmentDistance(evt.pixel, pixel1, pixel2);\n              if (dist < 8) { // 8 pixels tolerance for segment\n                const segFeature = new Feature(new LineString(seg));\n                segFeature.setStyle(highlightSegmentStyle);\n                highlightSource.addFeature(segFeature);\n                found = true;\n                return true; // Stop after first found\n              }\n            }\n          }\n          return found;\n        });\n      }\n    });\n\n    function editExistingPolygon(snappedCoord, vectorSource) {\n      // Find a LineString whose endpoint matches snappedCoord\n      let foundLine = null;\n      let foundIndex = null;\n      vectorSource.getFeatures().forEach(feature => {\n        if (feature.getGeometry().getType() === 'LineString') {\n          const coords = feature.getGeometry().getCoordinates();\n          // Check both ends\n          if (coordsEqual(coords[0], snappedCoord)) {\n            foundLine = feature;\n            foundIndex = 0;\n          } else if (coordsEqual(coords[coords.length - 1], snappedCoord)) {\n            foundLine = feature;\n            foundIndex = coords.length - 1;\n          }\n        }\n      });\n\n      if (foundLine) {\n        // Remove the LineString from the source\n        clearPolygonOverlays(foundLine, mapRef);\n        vectorSource.removeFeature(foundLine);\n        let coords = foundLine.getGeometry().getCoordinates();\n        // If the user clicked the end, reverse so snappedCoord is first\n        if (foundIndex === coords.length - 1) {\n          coords = coords.slice().reverse();\n        }\n        // Start a new polygon with these coords (not closed yet)\n        return coords;\n      }\n      // No matching linestring found\n      return null;\n    }\n\n    function drawClick(evt) {\n      const coord = evt.coordinate;\n      if (!drawingRef.current) {\n        if (ghostMarkerRef.current) {\n          vectorSourceRef.current.removeFeature(ghostMarkerRef.current);\n          ghostMarkerRef.current = null;\n        }\n\n        const pixel = mapRef.current.getPixelFromCoordinate(coord);\n\n        //custom snapping\n        const snappedCoord = getSnappedCoordinate(mapRef.current, vectorSourceRef.current, pixel, 25) || coord;\n\n        const vectorSource = vectorSourceRef.current;\n        let initialCoords = editExistingPolygon(snappedCoord, vectorSource);\n\n        let poly, feature;\n\n        if (initialCoords) {\n          // Remove all instances of snappedCoord from the array\n          let coords = initialCoords.filter(c => !coordsEqual(c, snappedCoord));\n          // Push snappedCoord to the end\n          coords.push(snappedCoord);\n\n          // Ensure the polygon is closed visually\n          if (\n            coords.length > 2 &&\n            (coords[0][0] !== coords[coords.length - 1][0] ||\n              coords[0][1] !== coords[coords.length - 1][1])\n          ) {\n            coords.push([...coords[0]]);\n          }\n\n          console.log({ NEWPOLY: coords });\n          // Create the polygon (now closed)\n          poly = new Polygon([coords]);\n          feature = new Feature(poly);\n          feature.setId(Date.now().toString());\n          createSegmentOverlays(feature, mapRef);\n          addHistoryAction({\n            type: 'convert-linestring-to-polygon',\n            featureId: feature.getId(),\n            prevCoords: initialCoords, // original LineString coordinates\n            newCoords: coords,         // new Polygon coordinates\n            geomType: 'Polygon',\n            prevGeomType: 'LineString'\n          });\n        } else {\n          // Normal: start polygon with just the clicked point\n          poly = new Polygon([[snappedCoord, snappedCoord]]);\n          feature = new Feature(poly);\n          feature.setId(Date.now().toString());\n          addHistoryAction({\n            type: 'add-point',\n            featureId: feature.getId(),\n            prevCoords: [],\n            newCoords: [[coord, coord]],\n          });\n        }\n\n        feature.setStyle(activePolygonStyle);\n        vectorSource.addFeature(feature);\n        polygonFeatureRef.current = feature;\n        drawingRef.current = true;\n        setDrawing(true);\n      }\n    }\n\n    function selectClick(evt) { // maybe\n      const features = map.getFeaturesAtPixel(evt.pixel).filter(f => vectorSourceRef.current.getFeatures().includes(f));\n      // const features = map.getFeaturesAtPixel(evt.pixel);\n      const allPolygons = vectorSourceRef.current.getFeatures();\n\n      if (!features || features.length === 0) {\n        // Deselect all: reset style for all polygons\n        allPolygons.forEach(f => f.setStyle(polygonStyle));\n        setSelectedFeature(null);\n        return;\n      }\n\n      let currentIdx = -1;\n      // Cycle to the next feature\n      const nextIdx = (currentIdx + 1) % features.length;\n      const nextFeature = features[nextIdx];\n\n      setSelectedFeature(nextFeature);\n    }\n\n    // --- MAP CLICK HANDLER ---\n    map.on('singleclick', evt => {\n      //DISABLED CLICK TO DRAW\n      if (modeRef.current === 'draw' && ghostMarkerRef.current) {\n        console.log('draw clicked');\n        drawClick(evt);\n      }\n      if (modeRef.current === 'select') {\n        selectClick(evt);\n      }\n    });\n\n    function addSegment(direction) {\n      if (!drawingRef.current) return;\n      const feature = polygonFeatureRef.current;\n      const poly = feature.getGeometry();\n      let coords = poly.getCoordinates()[0];\n      const last = coords.length === 1 ? coords[0] : coords[coords.length - 2];\n\n      let dx = 0, dy = 0;\n      const OFFSET = offsetRef.current;\n      switch (direction) {\n        case 'ArrowUp': dy = OFFSET; break;\n        case 'ArrowDown': dy = -OFFSET; break;\n        case 'ArrowLeft': dx = -OFFSET; break;\n        case 'ArrowRight': dx = OFFSET; break;\n        default: return;\n      }\n\n      // Rotate the direction vector by the negative of the map's rotation\n      const map = mapRef.current;\n      const rotation = map ? map.getView().getRotation() : 0;\n      const cos = Math.cos(rotation);\n      const sin = Math.sin(rotation);\n      const rotatedDx = dx * cos - dy * sin;\n      const rotatedDy = dx * sin + dy * cos;\n\n      const newPt = [last[0] + rotatedDx, last[1] + rotatedDy];\n\n      const prevCoords = [...coords];\n      coords = [...coords.slice(0, -1), newPt, coords[coords.length - 1]];\n      console.log({ AddSegmentCoords: coords });\n      poly.setCoordinates([coords]);\n      updateClosingSegmentOverlay();\n      createSegmentOverlays(feature, mapRef);\n\n      // Track action in history\n      addHistoryAction({\n        type: 'add-point',\n        featureId: feature.getId(),\n        prevCoords,\n        newCoords: coords,\n      });\n    }\n\n    function handleUndo() {\n      let lastActionForRedo = null;\n      setHistory(prev => {\n        if (prev.length === 0) return prev;\n        const lastAction = prev[prev.length - 1];\n        lastActionForRedo = lastAction;\n\n        // Find the feature by ID\n        let feature = null;\n        if (lastAction.featureId) {\n          feature = vectorSourceRef.current.getFeatures().find(f => f.getId() === lastAction.featureId);\n          if (!feature && polygonFeatureRef.current) feature = polygonFeatureRef.current;\n        } else if (polygonFeatureRef.current) {\n          feature = polygonFeatureRef.current;\n        }\n        if (!feature) return prev.slice(0, -1);\n\n        const prevCoords = lastAction.prevCoords;\n\n        if (lastAction.type === 'delete-segment') {\n          // Remove the current feature (could be a LineString or Polygon)\n          let featureToRemove = vectorSourceRef.current.getFeatures().find(\n            f => f.getId && f.getId() === lastAction.featureId\n          );\n          if (featureToRemove) {\n            clearPolygonOverlays(featureToRemove, mapRef);\n            vectorSourceRef.current.removeFeature(featureToRemove);\n          }\n\n          let restoredFeature;\n          if (lastAction.geomType === 'Polygon') {\n            restoredFeature = new Feature(new Polygon([lastAction.prevCoords]));\n          } else if (lastAction.geomType === 'LineString') {\n            restoredFeature = new Feature(new LineString(lastAction.prevCoords));\n          }\n          if (restoredFeature && lastAction.featureId) restoredFeature.setId(lastAction.featureId);\n          if (restoredFeature) {\n            vectorSourceRef.current.addFeature(restoredFeature);\n            polygonFeatureRef.current = restoredFeature;\n            if (lastAction.prevCoords && lastAction.prevCoords.length > 1) {\n              updateClosingSegmentOverlay();\n              createSegmentOverlays(restoredFeature, mapRef);\n            }\n          }\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'flip-horizontal' || lastAction.type === 'flip-vertical') {\n          if (feature) {\n            feature.getGeometry().setCoordinates([lastAction.prevCoords]);\n            if (lastAction.prevCoords.length > 1) {\n              createSegmentOverlays(feature, mapRef);\n            }\n          }\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'move-feature') {\n          if (feature && lastAction.prevCoords) {\n            feature.getGeometry().setCoordinates(lastAction.prevCoords);\n            createSegmentOverlays(feature, mapRef);\n          }\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'draw-circle') {\n          // Remove the circle feature\n          let featureToRemove = vectorSourceRef.current.getFeatures().find(\n            f => f.getId && f.getId() === lastAction.featureId\n          );\n          if (featureToRemove) {\n            clearPolygonOverlays(featureToRemove, mapRef);\n            vectorSourceRef.current.removeFeature(featureToRemove);\n          }\n          return prev.slice(0, -1);\n        }\n\n        // If undoing would result in no points or just one, remove the feature and reset drawing state\n        if (!prevCoords || prevCoords.length <= 1) {\n          clearPolygonOverlays(feature, mapRef);\n          vectorSourceRef.current.removeFeature(feature);\n          polygonFeatureRef.current = null;\n          drawingRef.current = false;\n          setDrawing(false);\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'convert-linestring-to-polygon') {\n          // Remove the polygon feature\n          let featureToRemove = vectorSourceRef.current.getFeatures().find(\n            f => f.getId && f.getId() === lastAction.featureId\n          );\n          if (featureToRemove) {\n            clearPolygonOverlays(featureToRemove, mapRef);\n            vectorSourceRef.current.removeFeature(featureToRemove);\n          }\n          // Restore the original LineString\n          const restoredFeature = new Feature(new LineString(lastAction.prevCoords));\n          if (lastAction.featureId) restoredFeature.setId(lastAction.featureId);\n          vectorSourceRef.current.addFeature(restoredFeature);\n          polygonFeatureRef.current = restoredFeature;\n          createSegmentOverlays(restoredFeature, mapRef);\n          return prev.slice(0, -1);\n        }\n\n        // Otherwise, restore previous geometry\n        const geomType = feature.getGeometry().getType();\n        if (geomType === 'Polygon') {\n          feature.getGeometry().setCoordinates([prevCoords]);\n        } else if (geomType === 'LineString') {\n          feature.getGeometry().setCoordinates(prevCoords);\n        }\n        if (prevCoords.length > 1) {\n          updateClosingSegmentOverlay();\n          createSegmentOverlays(feature, mapRef);\n        }\n\n        return prev.slice(0, -1);\n      });\n      // Only push to redoStack ONCE per undo, after setHistory runs\n      if (lastActionForRedo) {\n        setRedoStack(redoPrev => [...redoPrev, lastActionForRedo]);\n      }\n    }\n\n    function handleRedo() {\n      setRedoStack(prev => {\n        if (prev.length === 0) return prev;\n        const lastAction = prev[prev.length - 1];\n\n        // Find the feature by ID\n        let feature = null;\n        if (lastAction.featureId) {\n          feature = vectorSourceRef.current.getFeatures().find(f => f.getId() === lastAction.featureId);\n          if (!feature && polygonFeatureRef.current) feature = polygonFeatureRef.current;\n        } else if (polygonFeatureRef.current) {\n          feature = polygonFeatureRef.current;\n        }\n\n        const newCoords = lastAction.newCoords;\n\n        if (lastAction.type === 'delete-segment') {\n          // Remove the polygon feature\n          if (feature) {\n            clearPolygonOverlays(feature, mapRef);\n            vectorSourceRef.current.removeFeature(feature);\n          }\n          // Create a new LineString feature with the newCoords\n          const LineString = require('ol/geom/LineString').default;\n          const lineFeature = new Feature(new LineString(newCoords));\n          if (lastAction.featureId) lineFeature.setId(lastAction.featureId);\n          vectorSourceRef.current.addFeature(lineFeature);\n          if (mapRef.current && mapRef.current.remarkLineSegments) {\n            mapRef.current.remarkLineSegments(lineFeature);\n          }\n          updateClosingSegmentOverlay();\n          setHistory(histPrev => [...histPrev, lastAction]);\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'add-point' || lastAction.type === 'delete-vertex') {\n          if (feature) {\n            feature.getGeometry().setCoordinates([newCoords]);\n            if (newCoords.length > 1) {\n              createSegmentOverlays(feature, mapRef);\n            }\n          }\n          updateClosingSegmentOverlay();\n          setHistory(histPrev => [...histPrev, lastAction]);\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'flip-horizontal' || lastAction.type === 'flip-vertical') {\n          if (feature) {\n            feature.getGeometry().setCoordinates([lastAction.newCoords]);\n            if (lastAction.newCoords.length > 1) {\n              createSegmentOverlays(feature, mapRef);\n            }\n          }\n          setHistory(histPrev => [...histPrev, lastAction]);\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'move-feature') {\n          if (feature && lastAction.newCoords) {\n            feature.getGeometry().setCoordinates(lastAction.newCoords);\n            createSegmentOverlays(feature, mapRef);\n          }\n          setHistory(histPrev => [...histPrev, lastAction]);\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'convert-linestring-to-polygon') {\n          // Remove the LineString feature\n          let featureToRemove = vectorSourceRef.current.getFeatures().find(\n            f => f.getId && f.getId() === lastAction.featureId\n          );\n          if (featureToRemove) {\n            clearPolygonOverlays(featureToRemove, mapRef);\n            vectorSourceRef.current.removeFeature(featureToRemove);\n          }\n          // Restore the Polygon\n          const restoredFeature = new Feature(new Polygon([lastAction.newCoords]));\n          if (lastAction.featureId) restoredFeature.setId(lastAction.featureId);\n          restoredFeature.setStyle(activePolygonStyle);\n          vectorSourceRef.current.addFeature(restoredFeature);\n          polygonFeatureRef.current = restoredFeature;\n          createSegmentOverlays(restoredFeature, mapRef);\n          updateClosingSegmentOverlay();\n          setHistory(histPrev => [...histPrev, lastAction]);\n          return prev.slice(0, -1);\n        }\n\n        if (lastAction.type === 'draw-circle') {\n          // Re-add the circle feature\n          const restoredFeature = new Feature(new Polygon(lastAction.coords));\n          if (lastAction.featureId) restoredFeature.setId(lastAction.featureId);\n          vectorSourceRef.current.addFeature(restoredFeature);\n          setHistory(histPrev => [...histPrev, lastAction]);\n          return prev.slice(0, -1);\n        }\n\n        // Add more redo logic for other action types as needed...\n\n        return prev;\n      });\n    }\n\n    function rotateMapToHighlightedSegment(map, highlightSource) {\n      const features = highlightSource.getFeatures();\n      const segFeature = features.find(f => f.getGeometry().getType() === 'LineString');\n      if (!segFeature) return;\n\n      const coords = segFeature.getGeometry().getCoordinates();\n      if (coords.length < 2) return;\n\n      const [start, end] = coords;\n\n      const view = map.getView();\n      const currentRotation = view.getRotation();\n\n      const startPixel = map.getPixelFromCoordinate(start);\n      const endPixel = map.getPixelFromCoordinate(end);\n\n      // Undo current rotation to get true screen-space angle\n      const cos = Math.cos(-currentRotation);\n      const sin = Math.sin(-currentRotation);\n\n      const dx = endPixel[0] - startPixel[0];\n      const dy = endPixel[1] - startPixel[1];\n\n      const unrotatedDx = dx * cos - dy * sin;\n      const unrotatedDy = dx * sin + dy * cos;\n\n      const angle = Math.atan2(unrotatedDy, unrotatedDx);\n      const rotation = Math.PI / 2 - angle;\n\n      // Center on the midpoint of the segment\n      const center = [\n        (start[0] + end[0]) / 2,\n        (start[1] + end[1]) / 2\n      ];\n\n      view.animate({\n        center,\n        rotation,\n        duration: 600\n      });\n    }\n\n\n    function handleKeyDown(e) {\n      if (\n        e.key === 'ArrowUp' ||\n        e.key === 'ArrowDown' ||\n        e.key === 'ArrowLeft' ||\n        e.key === 'ArrowRight'\n      ) {\n        if (modeRef.current === 'draw') {\n          e.preventDefault();\n          addSegment(e.key);\n        }\n      }\n\n      // 'Enter' to calculate next line from the textbox input\n      if (e.key === 'Enter' && drawingRef.current && modeRef.current === 'draw') {\n        const feature = polygonFeatureRef.current;\n        const poly = feature.getGeometry();\n        let coords = poly.getCoordinates()[0];\n        const last = coords.length === 1 ? coords[0] : coords[coords.length - 2];\n\n        const input = textRef.current.trim().toUpperCase();\n\n        let dx = 0, dy = 0;\n\n        // 1. Handle direction notation (e.g. R10+U5)\n        const dirPattern = /^([RLUD]\\d+(\\+\\s*[RLUD]\\d+)*)$/;\n        if (dirPattern.test(input)) {\n          // Split by '+'\n          const parts = input.split('+').map(s => s.trim());\n          for (const part of parts) {\n            const dir = part[0];\n            const val = parseFloat(part.slice(1));\n            if (isNaN(val)) continue;\n            const meters = val * 0.3048;\n            switch (dir) {\n              case 'R': dx += meters; break;\n              case 'L': dx -= meters; break;\n              case 'U': dy += meters; break;\n              case 'D': dy -= meters; break;\n              default: break;\n            }\n          }\n          // Rotate the direction vector by the map's rotation\n          const map = mapRef.current;\n          const rotation = map ? map.getView().getRotation() : 0;\n          const cos = Math.cos(rotation);\n          const sin = Math.sin(rotation);\n          const rotatedDx = dx * cos - dy * sin;\n          const rotatedDy = dx * sin + dy * cos;\n          const newPt = [last[0] + rotatedDx, last[1] + rotatedDy];\n\n          const prevCoords = [...coords];\n          coords = [...coords.slice(0, -1), newPt, coords[coords.length - 1]];\n          poly.setCoordinates([coords]);\n          updateClosingSegmentOverlay();\n          createSegmentOverlays(feature, mapRef);\n\n          addHistoryAction({\n            type: 'add-point',\n            featureId: feature.getId(),\n            prevCoords,\n            newCoords: coords,\n          });\n\n          setText('');\n          return;\n        }\n\n        // 2. Handle length/angle notation (e.g. 10/180)\n        let distance = 0;\n        let angleDeg = 0;\n        if (input.includes('/')) {\n          const [distStr, angleStr] = input.split('/');\n          distance = parseFloat(distStr);\n          angleDeg = parseFloat(angleStr);\n        } else {\n          distance = parseFloat(input);\n          angleDeg = 0;\n        }\n        if (isNaN(distance)) return; // Invalid input\n\n        distance = distance * 0.3048;\n        const map = mapRef.current;\n        const rotation = map ? map.getView().getRotation() : 0;\n        const angleRad = (angleDeg * Math.PI) / 180 + rotation;\n\n        const dx2 = distance * Math.cos(angleRad);\n        const dy2 = distance * Math.sin(angleRad);\n        const newPt = [last[0] + dx2, last[1] + dy2];\n\n        const prevCoords = [...coords];\n        coords = [...coords.slice(0, -1), newPt, coords[coords.length - 1]];\n        poly.setCoordinates([coords]);\n        createSegmentOverlays(feature, mapRef);\n\n        addHistoryAction({\n          type: 'add-point',\n          featureId: feature.getId(),\n          prevCoords,\n          newCoords: coords,\n        });\n\n        setText('');\n      }\n\n      // 'a' to finish polygon\n      if ((e.key === 'a' || e.key === 'A') && drawingRef.current && modeRef.current === 'draw') {\n        const feature = polygonFeatureRef.current;\n        const poly = feature.getGeometry();\n        let coords = poly.getCoordinates()[0];\n        if (coords.length > 2) {\n          coords[coords.length - 1] = coords[0];\n          poly.setCoordinates([coords]);\n          feature.setStyle(polygonStyle);\n          createSegmentOverlays(feature, mapRef);\n          drawingRef.current = false;\n          setDrawing(false);\n          setMode('');\n        }\n        const highlightLayer = mapRef.current.getLayers().getArray().find(layer => layer.get('name') === 'highlight');\n        if (highlightLayer) {\n          const highlightSource = highlightLayer.getSource();\n          highlightSource.getFeatures().forEach(f => {\n            if (f.get('isClosingSegment')) highlightSource.removeFeature(f);\n          });\n        }\n\n      }\n      // ctrl + z\n      if (\n        (e.ctrlKey || e.metaKey) &&\n        (e.key === 'z' || e.key === 'Z')\n      ) {\n        e.preventDefault();\n        handleUndo();\n      }\n      // ctrl + y\n      if (\n        (e.ctrlKey || e.metaKey) &&\n        (e.key === 'y' || e.key === 'Y')\n      ) {\n        e.preventDefault();\n        handleRedo();\n      }\n      //ctrl + r\n      if (\n        (e.ctrlKey || e.metaKey) &&\n        (e.key === 'r' || e.key === 'R')\n      ) {\n        e.preventDefault();\n        const map = mapRef.current;\n        const highlightLayer = map.getLayers().getArray().find(layer => layer.get('name') === 'highlight');\n        if (map && highlightLayer) {\n          rotateMapToHighlightedSegment(map, highlightLayer.getSource());\n        }\n      }\n    }\n    document.addEventListener('keydown', handleKeyDown);\n\n    // Clean up on unmount\n    return () => {\n      vectorSource.getFeatures().forEach(f => clearPolygonOverlays(f, mapRef));\n      map.setTarget(null);\n      document.removeEventListener('keydown', handleKeyDown);\n      if (selectInteractionRef.current) {\n        map.removeInteraction(selectInteractionRef.current);\n        selectInteractionRef.current = null;\n      }\n    };\n  }, []);\n\n  return (\n    <div>\n      <div id=\"dimension-input-container\">\n        <input\n          id=\"dimension-input\"\n          ref={inputRef}\n          type=\"text\"\n          value={text}\n          onChange={e => setText(e.target.value)}\n          placeholder=\"Dimension (ft.)\"\n          autoFocus\n          autoComplete='off'\n        />\n      </div>\n      <div id=\"map-menu-vert\">\n        <button\n          title=\"Draw\"\n          className={`map-button${mode === 'draw' ? ' active' : ''}`}\n          onClick={() => setMode('draw')}\n          disabled={mode === 'draw' && drawing}>\n          <DrawIcon />\n        </button>\n        <button\n          title=\"Select / Move\"\n          className={`map-button${mode === 'select' ? ' active' : ''}`}\n          onClick={() => setMode('select')}\n          disabled={mode === 'draw' && drawing}>\n          <HandIcon />\n        </button>\n        <QuickShape mapRef={mapRef} vectorSourceRef={vectorSourceRef} setDrawing={setDrawing} setMode={setMode} addHistoryAction={addHistoryAction} mode={mode} />\n      </div>\n      <div id=\"map-menu-horiz\">\n        <FlipHorizButton selectedFeature={selectedFeature} mapRef={mapRef} addHistoryAction={addHistoryAction} />\n        <FlipVertButton selectedFeature={selectedFeature} mapRef={mapRef} addHistoryAction={addHistoryAction} />\n        <Clone selectedFeature={selectedFeature} vectorSourceRef={vectorSourceRef} setSelectedFeature={setSelectedFeature} addHistoryAction={addHistoryAction} mapRef={mapRef} />\n        <div id=\"history-toggle\" className={`map-button${showHistory ? ' active' : ''}`} onClick={() => setShowHistory(v => !v)}>\n          History\n        </div>\n        {/* <div className=\"map-button\">Curve</div>\n        <div className=\"map-button\">QuickShape</div> */}\n      </div>\n      <div id=\"map\"></div>\n      <RightClick\n        mapRef={mapRef}\n        vectorSourceRef={vectorSourceRef}\n        contextMenu={contextMenu}\n        setContextMenu={setContextMenu}\n        clearPolygonOverlays={(feature) => clearPolygonOverlays(feature, mapRef)}\n        addHistoryAction={addHistoryAction}\n        drawing={drawing}\n      />\n      {showHistory && (\n        <History history={history} redoStack={redoStack} />\n      )}\n    </div>\n  );\n};\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}