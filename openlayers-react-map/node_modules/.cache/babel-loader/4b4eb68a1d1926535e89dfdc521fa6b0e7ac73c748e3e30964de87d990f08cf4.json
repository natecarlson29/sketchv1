{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultFillStyle } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\nvar CanvasPolygonBuilder = /** @class */function (_super) {\n  __extends(CanvasPolygonBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n  }\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle !== undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  };\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   */\n  CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(feature);\n  };\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ends, stride);\n    this.endGeometry(feature);\n  };\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(feature);\n  };\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  CanvasPolygonBuilder.prototype.finish = function () {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    var tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n    return _super.prototype.finish.call(this);\n  };\n  /**\n   * @private\n   */\n  CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n  return CanvasPolygonBuilder;\n}(CanvasBuilder);\nexport default CanvasPolygonBuilder;","map":{"version":3,"names":["CanvasBuilder","CanvasInstruction","beginPathInstruction","closePathInstruction","fillInstruction","strokeInstruction","defaultFillStyle","snap","CanvasPolygonBuilder","_super","__extends","tolerance","maxExtent","resolution","pixelRatio","call","prototype","drawFlatCoordinatess_","flatCoordinates","offset","ends","stride","state","fill","fillStyle","undefined","stroke","strokeStyle","numEnds","length","instructions","push","hitDetectionInstructions","i","end","myBegin","coordinates","myEnd","appendFlatLineCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","drawCircle","circleGeometry","feature","setFillStrokeStyles_","beginGeometry","SET_FILL_STYLE","SET_STROKE_STYLE","lineWidth","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","getFlatCoordinates","getStride","circleInstruction","CIRCLE","endGeometry","drawPolygon","polygonGeometry","getEnds","getOrientedFlatCoordinates","drawMultiPolygon","multiPolygonGeometry","endss","getEndss","ii","finish","reverseHitDetectionInstructions","updateFillStyle","createFill","updateStrokeStyle","applyStroke"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\render\\canvas\\PolygonBuilder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/PolygonBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, {\n  beginPathInstruction,\n  closePathInstruction,\n  fillInstruction,\n  strokeInstruction,\n} from './Instruction.js';\nimport {defaultFillStyle} from '../canvas.js';\nimport {snap} from '../../geom/flat/simplify.js';\n\nclass CanvasPolygonBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle !== undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatLineCoordinates(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        true,\n        !stroke\n      );\n      const moveToLineToInstruction = [\n        CanvasInstruction.MOVE_TO_LINE_TO,\n        myBegin,\n        myEnd,\n      ];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  }\n\n  /**\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   */\n  drawCircle(circleGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset,\n      ]);\n    }\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(\n      flatCoordinates,\n      0,\n      flatCoordinates.length,\n      stride,\n      false,\n      false\n    );\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawPolygon(polygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset,\n      ]);\n    }\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(\n      flatCoordinates,\n      0,\n      /** @type {Array<number>} */ (ends),\n      stride\n    );\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawMultiPolygon(multiPolygonGeometry, feature) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle,\n      ]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset,\n      ]);\n    }\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(\n        flatCoordinates,\n        offset,\n        endss[i],\n        stride\n      );\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    const tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n    return super.finish();\n  }\n\n  /**\n   * @private\n   */\n  setFillStrokeStyles_() {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n}\n\nexport default CanvasPolygonBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}