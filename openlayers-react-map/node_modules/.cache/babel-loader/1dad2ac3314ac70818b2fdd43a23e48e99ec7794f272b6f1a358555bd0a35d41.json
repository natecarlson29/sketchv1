{"ast":null,"code":"import LineString from'ol/geom/LineString';import Overlay from'ol/Overlay';// Format length in feet or miles\nexport function formatLength(line){const lengthMeters=line.getLength?line.getLength():0;const lengthFeet=lengthMeters*3.28084;return lengthFeet>5280?(lengthFeet/5280).toFixed(2)+' mi':lengthFeet.toFixed(2)+\"'\";}// Remove all overlays for a feature (Polygon or LineString)\nexport function clearPolygonOverlays(feature,mapRef){if(feature&&feature._segmentOverlays){feature._segmentOverlays.forEach(overlay=>{if(mapRef&&mapRef.current)mapRef.current.removeOverlay(overlay);});feature._segmentOverlays=[];}}// Create overlays for each segment of a Polygon or LineString\nexport function createSegmentOverlays(feature,coords,mapRef){clearPolygonOverlays(feature,mapRef);const DIM_OFFSET=17;feature._segmentOverlays=[];// For Polygon, use first ring; for LineString, use coords directly\nlet points=coords;if(feature.getGeometry().getType()==='Polygon'){points=coords[0];}for(let i=1;i<points.length;i++){const c1=points[i-1];const c2=points[i];const line=new LineString([c1,c2]);const length=formatLength(line);// Calculate perpendicular offset direction (in screen pixels)\nconst pixel1=mapRef.current.getPixelFromCoordinate(c1);const pixel2=mapRef.current.getPixelFromCoordinate(c2);const dx=pixel2[0]-pixel1[0];const dy=pixel2[1]-pixel1[1];const len=Math.sqrt(dx*dx+dy*dy);const perp=len===0?[0,0]:[dy/len,-(dx/len)];// Offset midpoint in screen pixels\nconst offsetMidPixel=[(pixel1[0]+pixel2[0])/2+perp[0]*DIM_OFFSET,(pixel1[1]+pixel2[1])/2+perp[1]*DIM_OFFSET];const offsetMidCoord=mapRef.current.getCoordinateFromPixel(offsetMidPixel);// Place the tooltip at the offset position\nconst tooltip=document.createElement('div');tooltip.className='segment-tooltip';tooltip.innerHTML=length;// Always keep the tooltip horizontal, regardless of map rotation\n// tooltip.style.transform = 'none';\n// Rotate the tooltip if the segment is nearly vertical\nconst angle=Math.atan2(dy,dx)*180/Math.PI;if(Math.abs(Math.abs(angle)-90)<20){tooltip.style.transform='rotate(-90deg)';}else{tooltip.style.transform='none';}const overlay=new Overlay({element:tooltip,position:offsetMidCoord,positioning:'center-center',stopEvent:false});mapRef.current.addOverlay(overlay);feature._segmentOverlays.push(overlay);}}// Remark segments for a Polygon\nexport function remarkPolygonSegments(feature,mapRef){if(!feature)return;const poly=feature.getGeometry();const coords=poly.getCoordinates()[0];createSegmentOverlays(feature,[coords],mapRef);}// Remark segments for a LineString\nexport function remarkLineSegments(lineFeature,mapRef){if(!mapRef.current||!lineFeature)return;createSegmentOverlays(lineFeature,lineFeature.getGeometry().getCoordinates(),mapRef);}// Calculate distance from a point to a line segment defined by two points\nexport function pointToSegmentDistance(p,p1,p2){// p, p1, p2: [x, y]\nconst x=p[0],y=p[1];const x1=p1[0],y1=p1[1];const x2=p2[0],y2=p2[1];const A=x-x1;const B=y-y1;const C=x2-x1;const D=y2-y1;const dot=A*C+B*D;const len_sq=C*C+D*D;let param=-1;if(len_sq!==0)param=dot/len_sq;let xx,yy;if(param<0){xx=x1;yy=y1;}else if(param>1){xx=x2;yy=y2;}else{xx=x1+param*C;yy=y1+param*D;}const dx=x-xx;const dy=y-yy;return Math.sqrt(dx*dx+dy*dy);}","map":{"version":3,"names":["LineString","Overlay","formatLength","line","lengthMeters","getLength","lengthFeet","toFixed","clearPolygonOverlays","feature","mapRef","_segmentOverlays","forEach","overlay","current","removeOverlay","createSegmentOverlays","coords","DIM_OFFSET","points","getGeometry","getType","i","length","c1","c2","pixel1","getPixelFromCoordinate","pixel2","dx","dy","len","Math","sqrt","perp","offsetMidPixel","offsetMidCoord","getCoordinateFromPixel","tooltip","document","createElement","className","innerHTML","angle","atan2","PI","abs","style","transform","element","position","positioning","stopEvent","addOverlay","push","remarkPolygonSegments","poly","getCoordinates","remarkLineSegments","lineFeature","pointToSegmentDistance","p","p1","p2","x","y","x1","y1","x2","y2","A","B","C","D","dot","len_sq","param","xx","yy"],"sources":["C:/Users/ncarl/Desktop/sketch/openlayers-react-map/src/map-helpers/Measurements.js"],"sourcesContent":["import LineString from 'ol/geom/LineString';\r\nimport Overlay from 'ol/Overlay';\r\n\r\n// Format length in feet or miles\r\nexport function formatLength(line) {\r\n  const lengthMeters = line.getLength ? line.getLength() : 0;\r\n  const lengthFeet = lengthMeters * 3.28084;\r\n  return lengthFeet > 5280\r\n    ? (lengthFeet / 5280).toFixed(2) + ' mi'\r\n    : lengthFeet.toFixed(2) + \"'\";\r\n}\r\n\r\n// Remove all overlays for a feature (Polygon or LineString)\r\nexport function clearPolygonOverlays(feature, mapRef) {\r\n  if (feature && feature._segmentOverlays) {\r\n    feature._segmentOverlays.forEach(overlay => {\r\n      if (mapRef && mapRef.current) mapRef.current.removeOverlay(overlay);\r\n    });\r\n    feature._segmentOverlays = [];\r\n  }\r\n}\r\n\r\n// Create overlays for each segment of a Polygon or LineString\r\nexport function createSegmentOverlays(feature, coords, mapRef) {\r\n  clearPolygonOverlays(feature, mapRef);\r\n  const DIM_OFFSET = 17;\r\n  feature._segmentOverlays = [];\r\n\r\n  // For Polygon, use first ring; for LineString, use coords directly\r\n  let points = coords;\r\n  if (feature.getGeometry().getType() === 'Polygon') {\r\n    points = coords[0];\r\n  }\r\n\r\nfor (let i = 1; i < points.length; i++) {\r\n  const c1 = points[i - 1];\r\n  const c2 = points[i];\r\n  const line = new LineString([c1, c2]);\r\n  const length = formatLength(line);\r\n\r\n  // Calculate perpendicular offset direction (in screen pixels)\r\n  const pixel1 = mapRef.current.getPixelFromCoordinate(c1);\r\n  const pixel2 = mapRef.current.getPixelFromCoordinate(c2);\r\n  const dx = pixel2[0] - pixel1[0];\r\n  const dy = pixel2[1] - pixel1[1];\r\n  const len = Math.sqrt(dx * dx + dy * dy);\r\n  const perp = len === 0 ? [0, 0] : [(dy / len), -(dx / len)];\r\n\r\n  // Offset midpoint in screen pixels\r\n  const offsetMidPixel = [\r\n    (pixel1[0] + pixel2[0]) / 2 + perp[0] * DIM_OFFSET,\r\n    (pixel1[1] + pixel2[1]) / 2 + perp[1] * DIM_OFFSET,\r\n  ];\r\n  const offsetMidCoord = mapRef.current.getCoordinateFromPixel(offsetMidPixel);\r\n\r\n  // Place the tooltip at the offset position\r\n  const tooltip = document.createElement('div');\r\n  tooltip.className = 'segment-tooltip';\r\n  tooltip.innerHTML = length;\r\n\r\n  // Always keep the tooltip horizontal, regardless of map rotation\r\n  // tooltip.style.transform = 'none';\r\n\r\n    // Rotate the tooltip if the segment is nearly vertical\r\n    const angle = Math.atan2(dy, dx) * 180 / Math.PI;\r\n    if (Math.abs(Math.abs(angle) - 90) < 20) {\r\n      tooltip.style.transform = 'rotate(-90deg)';\r\n    } else {\r\n      tooltip.style.transform = 'none';\r\n    }\r\n\r\n\r\n  const overlay = new Overlay({\r\n    element: tooltip,\r\n    position: offsetMidCoord,\r\n    positioning: 'center-center',\r\n    stopEvent: false,\r\n  });\r\n  mapRef.current.addOverlay(overlay);\r\n  feature._segmentOverlays.push(overlay);\r\n}\r\n}\r\n\r\n// Remark segments for a Polygon\r\nexport function remarkPolygonSegments(feature, mapRef) {\r\n  if (!feature) return;\r\n  const poly = feature.getGeometry();\r\n  const coords = poly.getCoordinates()[0];\r\n  createSegmentOverlays(feature, [coords], mapRef);\r\n}\r\n\r\n// Remark segments for a LineString\r\nexport function remarkLineSegments(lineFeature, mapRef) {\r\n  if (!mapRef.current || !lineFeature) return;\r\n  createSegmentOverlays(lineFeature, lineFeature.getGeometry().getCoordinates(), mapRef);\r\n}\r\n\r\n// Calculate distance from a point to a line segment defined by two points\r\nexport function pointToSegmentDistance(p, p1, p2) {\r\n  // p, p1, p2: [x, y]\r\n  const x = p[0], y = p[1];\r\n  const x1 = p1[0], y1 = p1[1];\r\n  const x2 = p2[0], y2 = p2[1];\r\n  const A = x - x1;\r\n  const B = y - y1;\r\n  const C = x2 - x1;\r\n  const D = y2 - y1;\r\n\r\n  const dot = A * C + B * D;\r\n  const len_sq = C * C + D * D;\r\n  let param = -1;\r\n  if (len_sq !== 0) param = dot / len_sq;\r\n\r\n  let xx, yy;\r\n  if (param < 0) {\r\n    xx = x1;\r\n    yy = y1;\r\n  } else if (param > 1) {\r\n    xx = x2;\r\n    yy = y2;\r\n  } else {\r\n    xx = x1 + param * C;\r\n    yy = y1 + param * D;\r\n  }\r\n\r\n  const dx = x - xx;\r\n  const dy = y - yy;\r\n  return Math.sqrt(dx * dx + dy * dy);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}