{"ast":null,"code":"import { WORKER_OFFSCREEN_CANVAS } from './has.js';\n/**\n * @module ol/dom\n */\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [opt_width] Canvas width.\n * @param {number} [opt_height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  var canvas;\n  if (opt_canvasPool && opt_canvasPool.length) {\n    canvas = opt_canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (opt_width) {\n    canvas.width = opt_width;\n  }\n  if (opt_height) {\n    canvas.height = opt_height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {CanvasRenderingContext2D} */canvas.getContext('2d', opt_Context2DSettings);\n}\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\nexport function releaseCanvas(context) {\n  var canvas = context.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  context.clearRect(0, 0, 1, 1);\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n  var width = element.offsetWidth;\n  var style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n  return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n  var height = element.offsetHeight;\n  var style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n  return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n  var parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n  var oldChildren = node.childNodes;\n  for (var i = 0; true; ++i) {\n    var oldChild = oldChildren[i];\n    var newChild = children[i];\n    // check if our work is done\n    if (!oldChild && !newChild) {\n      break;\n    }\n    // check if children match\n    if (oldChild === newChild) {\n      continue;\n    }\n    // check if a new child needs to be added\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    }\n    // check if an old child needs to be removed\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    }\n    // reorder\n    node.insertBefore(newChild, oldChild);\n  }\n}","map":{"version":3,"names":["WORKER_OFFSCREEN_CANVAS","createCanvasContext2D","opt_width","opt_height","opt_canvasPool","opt_Context2DSettings","canvas","length","shift","OffscreenCanvas","document","createElement","width","height","getContext","releaseCanvas","context","clearRect","outerWidth","element","offsetWidth","style","getComputedStyle","parseInt","marginLeft","marginRight","outerHeight","offsetHeight","marginTop","marginBottom","replaceNode","newNode","oldNode","parent","parentNode","replaceChild","removeNode","node","removeChild","removeChildren","lastChild","replaceChildren","children","oldChildren","childNodes","i","oldChild","newChild","appendChild","insertBefore"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\dom.js"],"sourcesContent":["import {WORKER_OFFSCREEN_CANVAS} from './has.js';\n\n/**\n * @module ol/dom\n */\n\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [opt_width] Canvas width.\n * @param {number} [opt_height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(\n  opt_width,\n  opt_height,\n  opt_canvasPool,\n  opt_Context2DSettings\n) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (opt_canvasPool && opt_canvasPool.length) {\n    canvas = opt_canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (opt_width) {\n    canvas.width = opt_width;\n  }\n  if (opt_height) {\n    canvas.height = opt_height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {CanvasRenderingContext2D} */ (\n    canvas.getContext('2d', opt_Context2DSettings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\nexport function releaseCanvas(context) {\n  const canvas = context.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  context.clearRect(0, 0, 1, 1);\n}\n\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n  let width = element.offsetWidth;\n  const style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n\n  return width;\n}\n\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n  let height = element.offsetHeight;\n  const style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n\n  return height;\n}\n\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n  const parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n  const oldChildren = node.childNodes;\n\n  for (let i = 0; true; ++i) {\n    const oldChild = oldChildren[i];\n    const newChild = children[i];\n\n    // check if our work is done\n    if (!oldChild && !newChild) {\n      break;\n    }\n\n    // check if children match\n    if (oldChild === newChild) {\n      continue;\n    }\n\n    // check if a new child needs to be added\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    }\n\n    // check if an old child needs to be removed\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    }\n\n    // reorder\n    node.insertBefore(newChild, oldChild);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}