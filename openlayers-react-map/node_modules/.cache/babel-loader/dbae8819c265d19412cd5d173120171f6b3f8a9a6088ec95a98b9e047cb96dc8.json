{"ast":null,"code":"/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { log2, modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /** @class */function () {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n   */\n  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    var transformInvCache = {};\n    var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      var key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    var destinationTopLeft = getTopLeft(targetExtent);\n    var destinationTopRight = getTopRight(targetExtent);\n    var destinationBottomRight = getBottomRight(targetExtent);\n    var destinationBottomLeft = getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n    if (this.wrapsXInSource_) {\n      var leftBound_1 = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(function (triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {\n          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      }.bind(this));\n    }\n    transformInvCache = {};\n  }\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  };\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    var needsSubdivision = false;\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        var targetQuadExtent = boundingExtent([a, b, c, d]);\n        var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n    var isNotFinite = 0;\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n            return;\n          }\n        }\n      }\n    }\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        var centerSrc = this.transformInv_(center);\n        var dx = void 0;\n        if (wrapsX) {\n          var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        var centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          var bcSrc = this.transformInv_(bc);\n          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          var daSrc = this.transformInv_(da);\n          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          var abSrc = this.transformInv_(ab);\n          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          var cdSrc = this.transformInv_(cd);\n          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n        return;\n      }\n    }\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  };\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  Triangulation.prototype.calculateSourceExtent = function () {\n    var extent = createEmpty();\n    this.triangles_.forEach(function (triangle, i, arr) {\n      var src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n    return extent;\n  };\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  Triangulation.prototype.getTriangles = function () {\n    return this.triangles_;\n  };\n  return Triangulation;\n}();\nexport default Triangulation;","map":{"version":3,"names":["boundingExtent","createEmpty","extendCoordinate","getArea","getBottomLeft","getBottomRight","getTopLeft","getTopRight","getWidth","intersects","getTransform","log2","modulo","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","opt_destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","addQuad_","leftBound_1","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","bind","prototype","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles"],"sources":["C:\\Users\\ncarl\\Desktop\\sketch\\openlayers-react-map\\node_modules\\ol\\src\\reproj\\Triangulation.js"],"sourcesContent":["/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {log2, modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    opt_destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (opt_destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              log2(\n                getArea(targetExtent) /\n                  (opt_destinationResolution *\n                    opt_destinationResolution *\n                    256 *\n                    256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(\n        function (triangle) {\n          if (\n            Math.max(\n              triangle.source[0][0],\n              triangle.source[1][0],\n              triangle.source[2][0]\n            ) -\n              leftBound >\n            this.sourceWorldWidth_ / 2\n          ) {\n            const newTriangle = [\n              [triangle.source[0][0], triangle.source[0][1]],\n              [triangle.source[1][0], triangle.source[1][1]],\n              [triangle.source[2][0], triangle.source[2][1]],\n            ];\n            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[0][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[1][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[2][0] -= this.sourceWorldWidth_;\n            }\n\n            // Rarely (if the extent contains both the dateline and prime meridian)\n            // the shift can in turn break some triangles.\n            // Detect this here and don't shift in such cases.\n            const minX = Math.min(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            const maxX = Math.max(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            if (maxX - minX < this.sourceWorldWidth_ / 2) {\n              triangle.source = newTriangle;\n            }\n          }\n        }.bind(this)\n      );\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}